/////////////////////////WARNING - AUTOGENERATED FILE//////////////////////////
//
//  FILENAME:   gen_evt_pa.cpp
//
//  PURPOSE :   Body of giant switch for generating parameter arays from
//              hci event pdus
//
//  Autogenerated from HCIPacker/autogen/templates/evt_switch.tpl by
//  devTools/bin/pdu/gencode.pl
//
///////////////////////////////////////////////////////////////////////////////

#include "hcipacker/hcieventpdu.h"
#include "hcipacker/legacy.h"
#include "app/bluestack/bluetooth.h"
#include "app/bluestack/hci.h"
#include <cassert>

#ifdef _WIN32
#include <malloc.h>
#endif

uint32 HCIPDUFactory::decomposeEventPDU( const PDU& hci , uint32 * toFill , BadPDUReason& why_failed )
{
#ifdef _WIN32
    /*
     * WARNING: _msize is only documentented to work using malloc, calloc, and realloc. It is not documented to work on new or new[] 
     *          but still works on Visual Studio 6. Linux should use valgrind if there are problems.
     *
     * Check that parameters[0] <= size of the allocated block.
	 */
	assert(toFill == 0 || _msize(toFill) >= toFill[0]);       
#endif

    bool ok = true;
    uint32 length = 0;
    if ( hci.channel() == PDU::hciCommand )
    {
        HCIEventPDU evt ( hci );
        if ( toFill )
            toFill[1] = evt.get_event_code();
        //  start after the length field and event code.
        length = 2;
        switch ( evt.get_event_code() )
        {
        case HCI_EV_COMMAND_COMPLETE :
            length = decomposeCommandCompletePDU ( hci , toFill , why_failed );
            break ;
        case HCI_EV_ULP:
            {
            HCI_EV_ULP_T_PDU pdu ( hci );

            if ( toFill )
            {
                uint8 len;
                uint8 * ptr = pdu.get_ulp_sub_event();
                int i = 0;
                len = pdu.get_event_length();
                while ( i < len)
                {
                    toFill[length + i] = *(ptr+i);
                    i++;
                }
            }
            length += pdu.get_event_length();
            }
            break;
        case HCI_EV_USER_PASSKEY_REQUEST :
            {
            HCI_EV_USER_PASSKEY_REQUEST_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        case HCI_EV_KEYPRESS_NOTIFICATION :
            {
            HCI_EV_KEYPRESS_NOTIFICATION_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get notification_type
            if ( toFill )
                toFill[length] = pdu.get_notification_type();
            length++;
            }
            break ;
        case HCI_EV_DATA_BUFFER_OVERFLOW :
            {
            HCI_EV_DATA_BUFFER_OVERFLOW_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get link_type
            if ( toFill )
                toFill[length] = pdu.get_link_type();
            length++;
            }
            break ;
        case HCI_EV_ACTIVE_ADDRESS :
            {
            HCI_EV_ACTIVE_ADDRESS_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr_fixed
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr_fixed();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        case HCI_EV_SYNC_CONN_COMPLETE :
            {
            HCI_EV_SYNC_CONN_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get link_type
            if ( toFill )
                toFill[length] = pdu.get_link_type();
            length++;
            //  get tx_interval
            if ( toFill )
                toFill[length] = pdu.get_tx_interval();
            length++;
            //  get wesco
            if ( toFill )
                toFill[length] = pdu.get_wesco();
            length++;
            //  get rx_packet_length
            if ( toFill )
                toFill[length] = pdu.get_rx_packet_length();
            length++;
            //  get tx_packet_length
            if ( toFill )
                toFill[length] = pdu.get_tx_packet_length();
            length++;
            //  get air_mode
            if ( toFill )
                toFill[length] = pdu.get_air_mode();
            length++;
            }
            break ;
        case HCI_EV_ALIAS_ADDRESS_REQ :
            {
            HCI_EV_ALIAS_ADDRESS_REQ_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        case HCI_EV_LINK_KEY_NOTIFICATION :
            {
            HCI_EV_LINK_KEY_NOTIFICATION_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get link_key
            if ( toFill )
            {
                LinkKey l = pdu.get_link_key();
                uint32 * ptr = toFill + length;
                ok = encodeBytes( (uint8*)l.get_data() , 16 , toFill , &ptr );
            }
            length += 16;
            //  get key_type
            if ( toFill )
                toFill[length] = pdu.get_key_type();
            length++;
            }
            break ;
        case HCI_EV_ALLOW_PRIVATE_PAIRING :
            {
            HCI_EV_ALLOW_PRIVATE_PAIRING_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            }
            break ;
        case HCI_EV_DISCONNECT_COMPLETE :
            {
            HCI_EV_DISCONNECT_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get reason
            if ( toFill )
                toFill[length] = pdu.get_reason();
            length++;
            }
            break ;
        case HCI_EV_INQUIRY_RESULT :
            {
            HCI_EV_INQUIRY_RESULT_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get num_responses
            if ( toFill )
                toFill[length] = pdu.get_num_responses();
            length++;
            //  get result
            int count = pdu.get_num_responses();
            const int size = 8;
            if ( toFill )
                for ( int i = 0 ; i < count ; i++ )
                {
                    InquiryResult r = pdu.get_result( i );
                    BluetoothDeviceAddress bda ( r.get_bd_addr() );
                    toFill[length + ( size * i )] = bda.get_lap();
                    toFill[length + ( size * i ) + 1] = bda.get_uap();
                    toFill[length + ( size * i ) + 2] = bda.get_nap();
                    toFill[length + ( size * i ) + 3] = r.get_page_scan_repetition_mode();
                    toFill[length + ( size * i ) + 4] = r.get_page_scan_period_mode();
                    toFill[length + ( size * i ) + 5] = r.get_page_scan_mode();
                    toFill[length + ( size * i ) + 6] = r.get_class_of_device();
                    toFill[length + ( size * i ) + 7] = r.get_clock_offset();
                }
            length += count * size;
            }
            break ;
        case HCI_EV_LST_CHANGE :
            {
            HCI_EV_LST_CHANGE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get timeout
            if ( toFill )
                toFill[length] = pdu.get_timeout();
            length++;
            }
            break ;
        case HCI_EV_COMMAND_STATUS :
            {
            HCI_EV_COMMAND_STATUS_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get num_hci_command_pkts
            if ( toFill )
                toFill[length] = pdu.get_num_hci_command_pkts();
            length++;
            //  get op_code
            if ( toFill )
                toFill[length] = pdu.get_op_code();
            length++;
            }
            break ;
        case HCI_EV_ENCRYPTION_KEY_REFRESH_COMPLETE :
            {
            HCI_EV_ENCRYPTION_KEY_REFRESH_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            }
            break ;
        case HCI_EV_READ_CLOCK_OFFSET_COMPLETE :
            {
            HCI_EV_READ_CLOCK_OFFSET_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get clock_offset
            if ( toFill )
                toFill[length] = pdu.get_clock_offset();
            length++;
            }
            break ;
        case HCI_EV_CONN_REQUEST :
            {
            HCI_EV_CONN_REQUEST_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get dev_class
            if ( toFill )
                toFill[length] = pdu.get_dev_class();
            length++;
            //  get link_type
            if ( toFill )
                toFill[length] = pdu.get_link_type();
            length++;
            }
            break ;
        case HCI_EV_MODE_CHANGE :
            {
            HCI_EV_MODE_CHANGE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get curr_mode
            if ( toFill )
                toFill[length] = pdu.get_curr_mode();
            length++;
            //  get interval
            if ( toFill )
                toFill[length] = pdu.get_interval();
            length++;
            }
            break ;
        case HCI_EV_USER_PASSKEY_NOTIFICATION :
            {
            HCI_EV_USER_PASSKEY_NOTIFICATION_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get passkey
            if ( toFill )
                toFill[length] = pdu.get_passkey();
            length++;
            }
            break ;
        case HCI_EV_FIXED_ADDRESS_ATTEMPT :
            {
            HCI_EV_FIXED_ADDRESS_ATTEMPT_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get reserved
            if ( toFill )
                toFill[length] = pdu.get_reserved();
            length++;
            }
            break ;
        case HCI_EV_READ_REM_SUPP_FEATURES_COMPLETE :
            {
            HCI_EV_READ_REM_SUPP_FEATURES_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get lmp_supp_features
            if ( toFill )
            {
                LMPSupportedFeatures f = pdu.get_lmp_supp_features();
                uint32 * ptr = toFill + length;
                ok = encodeBytes( f.get_data() , 8 , toFill , &ptr );
            }
            length += 8;
            }
            break ;
        case HCI_EV_REMOTE_NAME_REQ_COMPLETE :
            {
            HCI_EV_REMOTE_NAME_REQ_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get name_part
            if ( toFill )
            {
                BluetoothName n = pdu.get_name_part();
                uint32 * ptr = toFill + length;
                ok = encodeBytes( (uint8*)n.get_str() , 248 , toFill , &ptr );
            }
            length += 248;
            }
            break ;
        case HCI_EV_CONN_COMPLETE :
            {
            HCI_EV_CONN_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get link_type
            if ( toFill )
                toFill[length] = pdu.get_link_type();
            length++;
            //  get enc_mode
            if ( toFill )
                toFill[length] = pdu.get_enc_mode();
            length++;
            }
            break ;
        case HCI_EV_REM_HOST_SUPPORTED_FEATURES :
            {
            HCI_EV_REM_HOST_SUPPORTED_FEATURES_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get host_features
            if ( toFill )
            {
                LMPExtFeatures f = pdu.get_host_features();
                uint32 * ptr = toFill + length;
                ok = encodeBytes( f.get_data() , 8 , toFill , &ptr );
            }
            length += 8;
            }
            break ;
        case HCI_EV_GENERATE_ALIAS_REQ :
            {
            HCI_EV_GENERATE_ALIAS_REQ_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            }
            break ;
        case HCI_EV_READ_REMOTE_VER_INFO_COMPLETE :
            {
            HCI_EV_READ_REMOTE_VER_INFO_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get lmp_version
            if ( toFill )
                toFill[length] = pdu.get_lmp_version();
            length++;
            //  get manuf_name
            if ( toFill )
                toFill[length] = pdu.get_manuf_name();
            length++;
            //  get lmp_subversion
            if ( toFill )
                toFill[length] = pdu.get_lmp_subversion();
            length++;
            }
            break ;
        case HCI_EV_EXTENDED_INQUIRY_RESULT :
            {
            HCI_EV_EXTENDED_INQUIRY_RESULT_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get num_responses
            if ( toFill )
                toFill[length] = pdu.get_num_responses();
            length++;
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get page_scan_rep_mode
            if ( toFill )
                toFill[length] = pdu.get_page_scan_rep_mode();
            length++;
            //  get page_scan_period_mode
            if ( toFill )
                toFill[length] = pdu.get_page_scan_period_mode();
            length++;
            //  get dev_class
            if ( toFill )
                toFill[length] = pdu.get_dev_class();
            length++;
            //  get clock_offset
            if ( toFill )
                toFill[length] = pdu.get_clock_offset();
            length++;
            //  get rssi
            if ( toFill )
                toFill[length] = pdu.get_rssi();
            length++;
            //  get eir_data_part
            if ( toFill )
            {
                EIRData d = pdu.get_eir_data_part();
                uint32 * ptr = toFill + length;
                ok = encodeBytes( (uint8*)d.get_data() , 240 , toFill , &ptr );
            }
            length += 240;
            }
            break ;
        case HCI_EV_IO_CAPABILITY_REQUEST :
            {
            HCI_EV_IO_CAPABILITY_REQUEST_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        case HCI_EV_IO_CAPABILITY_RESPONSE :
            {
            HCI_EV_IO_CAPABILITY_RESPONSE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get io_capability
            if ( toFill )
                toFill[length] = pdu.get_io_capability();
            length++;
            //  get oob_data_present
            if ( toFill )
                toFill[length] = pdu.get_oob_data_present();
            length++;
            //  get authentication_requirements
            if ( toFill )
                toFill[length] = pdu.get_authentication_requirements();
            length++;
            }
            break ;
        case HCI_EV_ROLE_CHANGE :
            {
            HCI_EV_ROLE_CHANGE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get new_role
            if ( toFill )
                toFill[length] = pdu.get_new_role();
            length++;
            }
            break ;
        case HCI_EV_LINK_KEY_REQ :
            {
            HCI_EV_LINK_KEY_REQ_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        case HCI_EV_USER_CONFIRMATION_REQUEST :
            {
            HCI_EV_USER_CONFIRMATION_REQUEST_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get numeric_value
            if ( toFill )
                toFill[length] = pdu.get_numeric_value();
            length++;
            }
            break ;
        case HCI_EV_FLOW_SPEC_COMPLETE :
            {
            HCI_EV_FLOW_SPEC_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get flags
            if ( toFill )
                toFill[length] = pdu.get_flags();
            length++;
            //  get flow_direction
            if ( toFill )
                toFill[length] = pdu.get_flow_direction();
            length++;
            //  get service_type
            if ( toFill )
                toFill[length] = pdu.get_service_type();
            length++;
            //  get token_rate
            if ( toFill )
                toFill[length] = pdu.get_token_rate();
            length++;
            //  get token_bucket_size
            if ( toFill )
                toFill[length] = pdu.get_token_bucket_size();
            length++;
            //  get peak_bandwidth
            if ( toFill )
                toFill[length] = pdu.get_peak_bandwidth();
            length++;
            //  get access_latency
            if ( toFill )
                toFill[length] = pdu.get_access_latency();
            length++;
            }
            break ;
        case HCI_EV_REMOTE_OOB_DATA_REQUEST :
            {
            HCI_EV_REMOTE_OOB_DATA_REQUEST_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        case HCI_EV_MASTER_LINK_KEY_COMPLETE :
            {
            HCI_EV_MASTER_LINK_KEY_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get key_flag
            if ( toFill )
                toFill[length] = pdu.get_key_flag();
            length++;
            }
            break ;
        case HCI_EV_SIMPLE_PAIRING_COMPLETE :
            {
            HCI_EV_SIMPLE_PAIRING_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        case HCI_EV_FLUSH_OCCURRED :
            {
            HCI_EV_FLUSH_OCCURRED_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            }
            break ;
        case HCI_EV_PAGE_SCAN_REP_MODE_CHANGE :
            {
            HCI_EV_PAGE_SCAN_REP_MODE_CHANGE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get page_scan_rep_mode
            if ( toFill )
                toFill[length] = pdu.get_page_scan_rep_mode();
            length++;
            }
            break ;
        case HCI_EV_MNFR_EXTENSION :
            {
            HCI_EV_MNFR_EXTENSION_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get payload_descriptor
            if ( toFill )
                toFill[length] = pdu.get_payload_descriptor();
            length++;
            //  get payload
            int count = pdu.get_payload_length();
            if ( toFill )
            {
                uint32 * ptr = toFill + length;
                ok = encodeBytes( (uint8*)pdu.get_payload() , count , toFill , &ptr );
            }
            length += count;
            }
            break ;
        case HCI_EV_CONN_PACKET_TYPE_CHANGED :
            {
            HCI_EV_CONN_PACKET_TYPE_CHANGED_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get pkt_type
            if ( toFill )
                toFill[length] = pdu.get_pkt_type();
            length++;
            }
            break ;
        case HCI_EV_INQUIRY_RESULT_WITH_RSSI :
            {
            HCI_EV_INQUIRY_RESULT_WITH_RSSI_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get num_responses
            if ( toFill )
                toFill[length] = pdu.get_num_responses();
            length++;
            //  get result
            int count = pdu.get_num_responses();
            const int size = 8;
            if ( toFill )
                for ( int i = 0 ; i < count ; i++ )
                {
                    InquiryResultWithRSSI r = pdu.get_result( i );
                    BluetoothDeviceAddress bda ( r.get_bd_addr() );
                    toFill[length + ( size * i )] = bda.get_lap();
                    toFill[length + ( size * i ) + 1] = bda.get_uap();
                    toFill[length + ( size * i ) + 2] = bda.get_nap();
                    toFill[length + ( size * i ) + 3] = r.get_page_scan_repetition_mode();
                    toFill[length + ( size * i ) + 4] = r.get_page_scan_period_mode();
                    toFill[length + ( size * i ) + 5] = r.get_class_of_device();
                    toFill[length + ( size * i ) + 6] = r.get_clock_offset();
                    toFill[length + ( size * i ) + 7] = r.get_rssi();
                }
            length += count * size;
            }
            break ;
        case HCI_EV_HARDWARE_ERROR :
            {
            HCI_EV_HARDWARE_ERROR_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get hw_error
            if ( toFill )
                toFill[length] = pdu.get_hw_error();
            length++;
            }
            break ;
        case HCI_EV_SYNC_CONN_CHANGED :
            {
            HCI_EV_SYNC_CONN_CHANGED_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get tx_interval
            if ( toFill )
                toFill[length] = pdu.get_tx_interval();
            length++;
            //  get wesco
            if ( toFill )
                toFill[length] = pdu.get_wesco();
            length++;
            //  get rx_packet_length
            if ( toFill )
                toFill[length] = pdu.get_rx_packet_length();
            length++;
            //  get tx_packet_length
            if ( toFill )
                toFill[length] = pdu.get_tx_packet_length();
            length++;
            }
            break ;
        case HCI_EV_QOS_VIOLATION :
            {
            HCI_EV_QOS_VIOLATION_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            }
            break ;
        case HCI_EV_READ_REM_EXT_FEATURES_COMPLETE :
            {
            HCI_EV_READ_REM_EXT_FEATURES_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get page_num
            if ( toFill )
                toFill[length] = pdu.get_page_num();
            length++;
            //  get max_page_num
            if ( toFill )
                toFill[length] = pdu.get_max_page_num();
            length++;
            //  get lmp_ext_features
            if ( toFill )
            {
                LMPExtFeatures f = pdu.get_lmp_ext_features();
                uint32 * ptr = toFill + length;
                ok = encodeBytes( f.get_data() , 8 , toFill , &ptr );
            }
            length += 8;
            }
            break ;
        case HCI_EV_MAX_SLOTS_CHANGE :
            {
            HCI_EV_MAX_SLOTS_CHANGE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get lmp_max_slots
            if ( toFill )
                toFill[length] = pdu.get_lmp_max_slots();
            length++;
            }
            break ;
        case HCI_EV_ALIAS_ADDRESS :
            {
            HCI_EV_ALIAS_ADDRESS_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        case HCI_EV_RETURN_LINK_KEYS :
            {
            HCI_EV_RETURN_LINK_KEYS_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get number_keys
            if ( toFill )
                toFill[length] = pdu.get_number_keys();
            length++;
            //  get link_key_bd_addr
            int count = pdu.get_number_keys();
            const int size = 19;
            if ( toFill )
                for ( int i = 0 ; ok && i < count ; i++ )
                {
                    BluetoothDeviceAddress bda;
                    LinkKey lk;
                    pdu.get_link_key_bd_addr( i , bda , lk );
                    toFill[length + ( size * i )] = bda.get_lap();
                    toFill[length + ( size * i ) + 1] = bda.get_uap();
                    toFill[length + ( size * i ) + 2] = bda.get_nap();
                    uint32 * ptr = toFill + ( size * i ) + length + 3;
                    ok = encodeBytes( (uint8*)lk.get_data() , 16 , toFill , &ptr );
                }
            length += count * size;
            }
            break ;
        case HCI_EV_FIXED_ADDRESS :
            {
            HCI_EV_FIXED_ADDRESS_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        case HCI_EV_CHANGE_CONN_LINK_KEY_COMPLETE :
            {
            HCI_EV_CHANGE_CONN_LINK_KEY_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            }
            break ;
        case HCI_EV_SNIFF_SUB_RATE :
            {
            HCI_EV_SNIFF_SUB_RATE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get transmit_latency
            if ( toFill )
                toFill[length] = pdu.get_transmit_latency();
            length++;
            //  get receive_latency
            if ( toFill )
                toFill[length] = pdu.get_receive_latency();
            length++;
            //  get remote_timeout
            if ( toFill )
                toFill[length] = pdu.get_remote_timeout();
            length++;
            //  get local_timeout
            if ( toFill )
                toFill[length] = pdu.get_local_timeout();
            length++;
            }
            break ;
        case HCI_EV_INQUIRY_COMPLETE :
            {
            HCI_EV_INQUIRY_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            }
            break ;
        case HCI_EV_ALIAS_NOT_RECOGNISED :
            {
            HCI_EV_ALIAS_NOT_RECOGNISED_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        case HCI_EV_QOS_SETUP_COMPLETE :
            {
            HCI_EV_QOS_SETUP_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get flags
            if ( toFill )
                toFill[length] = pdu.get_flags();
            length++;
            //  get service_type
            if ( toFill )
                toFill[length] = pdu.get_service_type();
            length++;
            //  get token_rate
            if ( toFill )
                toFill[length] = pdu.get_token_rate();
            length++;
            //  get peak_bandwidth
            if ( toFill )
                toFill[length] = pdu.get_peak_bandwidth();
            length++;
            //  get latency
            if ( toFill )
                toFill[length] = pdu.get_latency();
            length++;
            //  get delay_variation
            if ( toFill )
                toFill[length] = pdu.get_delay_variation();
            length++;
            }
            break ;
        case HCI_EV_NUMBER_COMPLETED_PKTS :
            {
            HCI_EV_NUMBER_COMPLETED_PKTS_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get num_handles
            if ( toFill )
                toFill[length] = pdu.get_num_handles();
            length++;
            //  get num_completed_pkts_ptr
            uint8 count = pdu.get_num_handles();
            if ( toFill )
            {
                uint16 handle;
                uint16 ncp;
                int i = 0;
                while ( i < count )
                {
                    pdu.get_num_completed_pkts(i,handle,ncp);
                    toFill[length + (2*i)] = handle;
                    toFill[length + (2*i) + 1] = ncp;
                    i++;
                }
            }
            length += count * 2;
            }
            break ;
        case HCI_EV_AUTH_COMPLETE :
            {
            HCI_EV_AUTH_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            }
            break ;
        case HCI_EV_ENHANCED_FLUSH_COMPLETE :
            {
            HCI_EV_ENHANCED_FLUSH_COMPLETE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            }
            break ;
        case HCI_EV_PAGE_SCAN_MODE_CHANGE :
            {
            HCI_EV_PAGE_SCAN_MODE_CHANGE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            //  get page_scan_mode
            if ( toFill )
                toFill[length] = pdu.get_page_scan_mode();
            length++;
            }
            break ;
        case HCI_EV_ENCRYPTION_CHANGE :
            {
            HCI_EV_ENCRYPTION_CHANGE_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get status
            if ( toFill )
                toFill[length] = pdu.get_status();
            length++;
            //  get handle
            if ( toFill )
                toFill[length] = pdu.get_handle();
            length++;
            //  get enc_enable
            if ( toFill )
                toFill[length] = pdu.get_enc_enable();
            length++;
            }
            break ;
        case HCI_EV_LOOPBACK_COMMAND :
            {
            HCI_EV_LOOPBACK_COMMAND_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get loopback_part_ptr
            const PDU lb_pdu = pdu.get_loopback_part();
            int count = lb_pdu.size();
            if ( toFill )
            {
                uint32 * ptr = toFill + length;
                ok = encodeBytes( lb_pdu.data() , count , toFill , &ptr );
            }
            length += count;
            }
            break ;
        case HCI_EV_PIN_CODE_REQ :
            {
            HCI_EV_PIN_CODE_REQ_T_PDU pdu ( hci );
            if ( !(pdu.size_ok()&&pdu.size_expected()) )
            {
                why_failed = BP_HCI_WRONG_SIZE;
                length = 0;
                break;
            }
            //  get bd_addr
            if ( toFill )
            {
                BluetoothDeviceAddress bda = pdu.get_bd_addr();
                toFill[length] = bda.get_lap();
                toFill[length+1] = bda.get_uap();
                toFill[length+2] = bda.get_nap();
            }
            length += 3;
            }
            break ;
        default:
            // unrecognised type
            why_failed = BP_NO_SUCH_EVENT_CODE;
            ok = false;
            break;
        } // end switch 
    }
    assert ( ( toFill == 0 ) || ( toFill[0] >= length ) );
    if ( ok && toFill && length )
        toFill[0] = length;
    return ok ? length : 0;
} //end dumpPrim

/* empty creation of evt_build_tpl */
