/////////////////////////WARNING - AUTOGENERATED FILE//////////////////////////
//
//  FILENAME:   gen_cmd_pa.cpp
//
//  PURPOSE :   Body of giant switch for autogenerating hci command pdus
//
//  Autogenerated from HCIPacker/autogen/templates/cmd_switch.tpl
//  and HCIPacker/autogen/templates/cmd_build.tpl by
//  devTools/bin/pdu/gencode.pl
//
///////////////////////////////////////////////////////////////////////////////

// start of part generated by cmd_switch.tpl

#include "hcipacker/hcicommandpdu.h"
#include "hcipacker/legacy.h"
#include "app/bluestack/bluetooth.h"
#include "app/bluestack/hci.h"

static HCICommandPDU* createHCIComandPDU ( uint16 opcode )
{
    switch ( opcode )
    {
    case HCI_READ_INQUIRY_RESPONSE_TX_POWER_LEVEL :
        return new HCI_READ_INQUIRY_RESPONSE_TX_POWER_LEVEL_T_PDU();
    case HCI_READ_LMP_HANDLE :
        return new HCI_READ_LMP_HANDLE_T_PDU();
    case HCI_REJECT_SYNCHRONOUS_CONN_REQ :
        return new HCI_REJECT_SYNCHRONOUS_CONN_REQ_T_PDU();
    case HCI_ADD_SCO_CONNECTION :
        return new HCI_ADD_SCO_CONNECTION_T_PDU();
    case HCI_WRITE_ANON_MODE :
        return new HCI_WRITE_ANON_MODE_T_PDU();
    case HCI_SEND_KEYPRESS_NOTIFICATION :
        return new HCI_SEND_KEYPRESS_NOTIFICATION_T_PDU();
    case HCI_CHANGE_CONN_LINK_KEY :
        return new HCI_CHANGE_CONN_LINK_KEY_T_PDU();
    case HCI_ALIAS_ADDRESS_REQ_NEG_REPLY :
        return new HCI_ALIAS_ADDRESS_REQ_NEG_REPLY_T_PDU();
    case HCI_WRITE_AUTO_FLUSH_TIMEOUT :
        return new HCI_WRITE_AUTO_FLUSH_TIMEOUT_T_PDU();
    case HCI_WRITE_SCO_FLOW_CON_ENABLE :
        return new HCI_WRITE_SCO_FLOW_CON_ENABLE_T_PDU();
    case HCI_ULP_CREATE_CONNECTION_CANCEL :
        return new HCI_ULP_CREATE_CONNECTION_CANCEL_T_PDU();
    case HCI_READ_NUM_SUPPORTED_IAC :
        return new HCI_READ_NUM_SUPPORTED_IAC_T_PDU();
    case HCI_WRITE_AUTH_ENABLE :
        return new HCI_WRITE_AUTH_ENABLE_T_PDU();
    case HCI_READ_LINK_POLICY_SETTINGS :
        return new HCI_READ_LINK_POLICY_SETTINGS_T_PDU();
    case HCI_READ_SCO_FLOW_CON_ENABLE :
        return new HCI_READ_SCO_FLOW_CON_ENABLE_T_PDU();
    case HCI_ULP_CLEAR_WHITE_LIST :
        return new HCI_ULP_CLEAR_WHITE_LIST_T_PDU();
    case HCI_READ_STORED_LINK_KEY :
        return new HCI_READ_STORED_LINK_KEY_T_PDU();
    case HCI_SWITCH_ROLE :
        return new HCI_SWITCH_ROLE_T_PDU();
    case HCI_INQUIRY :
        return new HCI_INQUIRY_T_PDU();
    case HCI_READ_REMOTE_EXT_FEATURES :
        return new HCI_READ_REMOTE_EXT_FEATURES_T_PDU();
    case HCI_ULP_TRANSMITTER_TEST :
        return new HCI_ULP_TRANSMITTER_TEST_T_PDU();
    case HCI_WRITE_INQUIRY_SCAN_TYPE :
        return new HCI_WRITE_INQUIRY_SCAN_TYPE_T_PDU();
    case HCI_RESET :
        return new HCI_RESET_T_PDU();
    case HCI_ULP_RAND :
        return new HCI_ULP_RAND_T_PDU();
    case HCI_REFRESH_ENCRYPTION_KEY :
        return new HCI_REFRESH_ENCRYPTION_KEY_T_PDU();
    case HCI_EXCHANGE_FIXED_INFO :
        return new HCI_EXCHANGE_FIXED_INFO_T_PDU();
    case HCI_ULP_READ_ADVERTISING_CHANNEL_TX_POWER :
        return new HCI_ULP_READ_ADVERTISING_CHANNEL_TX_POWER_T_PDU();
    case HCI_SETUP_SYNCHRONOUS_CONN :
        return new HCI_SETUP_SYNCHRONOUS_CONN_T_PDU();
    case HCI_READ_INQUIRY_SCAN_TYPE :
        return new HCI_READ_INQUIRY_SCAN_TYPE_T_PDU();
    case HCI_FLUSH :
        return new HCI_FLUSH_T_PDU();
    case HCI_ULP_START_ENCRYPTION :
        return new HCI_ULP_START_ENCRYPTION_T_PDU();
    case HCI_ULP_READ_WHITE_LIST_SIZE :
        return new HCI_ULP_READ_WHITE_LIST_SIZE_T_PDU();
    case HCI_ULP_SET_SCAN_ENABLE :
        return new HCI_ULP_SET_SCAN_ENABLE_T_PDU();
    case HCI_SET_AFH_CHANNEL_CLASS :
        return new HCI_SET_AFH_CHANNEL_CLASS_T_PDU();
    case HCI_IO_CAPABILITY_RESPONSE :
        return new HCI_IO_CAPABILITY_RESPONSE_T_PDU();
    case HCI_SET_CONN_ENCRYPTION :
        return new HCI_SET_CONN_ENCRYPTION_T_PDU();
    case HCI_READ_PIN_TYPE :
        return new HCI_READ_PIN_TYPE_T_PDU();
    case HCI_ULP_LONG_TERM_KEY_REQUESTED_REPLY :
        return new HCI_ULP_LONG_TERM_KEY_REQUESTED_REPLY_T_PDU();
    case HCI_ULP_TEST_END :
        return new HCI_ULP_TEST_END_T_PDU();
    case HCI_HOST_NUM_COMPLETED_PACKETS :
        return new HCI_HOST_NUM_COMPLETED_PACKETS_T_PDU();
    case HCI_READ_REMOTE_SUPP_FEATURES :
        return new HCI_READ_REMOTE_SUPP_FEATURES_T_PDU();
    case HCI_READ_REMOTE_VER_INFO :
        return new HCI_READ_REMOTE_VER_INFO_T_PDU();
    case HCI_HOST_BUFFER_SIZE :
        return new HCI_HOST_BUFFER_SIZE_T_PDU();
    case HCI_ALIAS_ADDRESS_REQ_REPLY :
        return new HCI_ALIAS_ADDRESS_REQ_REPLY_T_PDU();
    case HCI_READ_PAGESCAN_MODE :
        return new HCI_READ_PAGESCAN_MODE_T_PDU();
    case HCI_WRITE_SIMPLE_PAIRING_MODE :
        return new HCI_WRITE_SIMPLE_PAIRING_MODE_T_PDU();
    case HCI_ULP_CONNECTION_UPDATE :
        return new HCI_ULP_CONNECTION_UPDATE_T_PDU();
    case HCI_READ_CLOCK :
        return new HCI_READ_CLOCK_T_PDU();
    case HCI_ENHANCED_FLUSH :
        return new HCI_ENHANCED_FLUSH_T_PDU();
    case HCI_READ_DEFAULT_LINK_POLICY_SETTINGS :
        return new HCI_READ_DEFAULT_LINK_POLICY_SETTINGS_T_PDU();
    case HCI_PERIODIC_INQUIRY_MODE :
        return new HCI_PERIODIC_INQUIRY_MODE_T_PDU();
    case HCI_MNFR_EXTENSION :
        return new HCI_MNFR_EXTENSION_T_PDU();
    case HCI_ROLE_DISCOVERY :
        return new HCI_ROLE_DISCOVERY_T_PDU();
    case HCI_SET_EVENT_FILTER :
        return new HCI_SET_EVENT_FILTER_T_PDU();
    case HCI_PRIVATE_PAIRING_REQ_REPLY :
        return new HCI_PRIVATE_PAIRING_REQ_REPLY_T_PDU();
    case HCI_READ_INQUIRYSCAN_ACTIVITY :
        return new HCI_READ_INQUIRYSCAN_ACTIVITY_T_PDU();
    case HCI_READ_SIMPLE_PAIRING_MODE :
        return new HCI_READ_SIMPLE_PAIRING_MODE_T_PDU();
    case HCI_WRITE_INQUIRY_MODE :
        return new HCI_WRITE_INQUIRY_MODE_T_PDU();
    case HCI_USER_CONFIRMATION_REQUEST_REPLY :
        return new HCI_USER_CONFIRMATION_REQUEST_REPLY_T_PDU();
    case HCI_WRITE_PAGE_TIMEOUT :
        return new HCI_WRITE_PAGE_TIMEOUT_T_PDU();
    case HCI_ULP_ADD_DEVICE_TO_WHITE_LIST :
        return new HCI_ULP_ADD_DEVICE_TO_WHITE_LIST_T_PDU();
    case HCI_READ_PAGESCAN_PERIOD_MODE :
        return new HCI_READ_PAGESCAN_PERIOD_MODE_T_PDU();
    case HCI_WRITE_PAGE_SCAN_TYPE :
        return new HCI_WRITE_PAGE_SCAN_TYPE_T_PDU();
    case HCI_REMOTE_NAME_REQ :
        return new HCI_REMOTE_NAME_REQ_T_PDU();
    case HCI_CREATE_CONNECTION_CANCEL :
        return new HCI_CREATE_CONNECTION_CANCEL_T_PDU();
    case HCI_READ_PAGE_SCAN_TYPE :
        return new HCI_READ_PAGE_SCAN_TYPE_T_PDU();
    case HCI_REMOTE_OOB_DATA_REQUEST_REPLY :
        return new HCI_REMOTE_OOB_DATA_REQUEST_REPLY_T_PDU();
    case HCI_READ_LOCAL_NAME :
        return new HCI_READ_LOCAL_NAME_T_PDU();
    case HCI_READ_LOCAL_VER_INFO :
        return new HCI_READ_LOCAL_VER_INFO_T_PDU();
    case HCI_DISCONNECT :
        return new HCI_DISCONNECT_T_PDU();
    case HCI_WRITE_AFH_CHANNEL_CLASS_M :
        return new HCI_WRITE_AFH_CHANNEL_CLASS_M_T_PDU();
    case HCI_ULP_SET_HOST_CHANNEL_CLASSIFICATION :
        return new HCI_ULP_SET_HOST_CHANNEL_CLASSIFICATION_T_PDU();
    case HCI_READ_ENC_MODE :
        return new HCI_READ_ENC_MODE_T_PDU();
    case HCI_READ_BD_ADDR :
        return new HCI_READ_BD_ADDR_T_PDU();
    case HCI_GENERATED_ALIAS :
        return new HCI_GENERATED_ALIAS_T_PDU();
    case HCI_PRIVATE_PAIRING_REQ_NEG_REPLY :
        return new HCI_PRIVATE_PAIRING_REQ_NEG_REPLY_T_PDU();
    case HCI_LINK_KEY_REQ_REPLY :
        return new HCI_LINK_KEY_REQ_REPLY_T_PDU();
    case HCI_WRITE_NUM_BCAST_RETXS :
        return new HCI_WRITE_NUM_BCAST_RETXS_T_PDU();
    case HCI_PIN_CODE_REQ_NEG_REPLY :
        return new HCI_PIN_CODE_REQ_NEG_REPLY_T_PDU();
    case HCI_WRITE_ALIAS_AUTH_ENABLE :
        return new HCI_WRITE_ALIAS_AUTH_ENABLE_T_PDU();
    case HCI_WRITE_LE_HOST_SUPPORT :
        return new HCI_WRITE_LE_HOST_SUPPORT_T_PDU();
    case HCI_MASTER_LINK_KEY :
        return new HCI_MASTER_LINK_KEY_T_PDU();
    case HCI_USER_CONFIRMATION_REQUEST_NEG_REPLY :
        return new HCI_USER_CONFIRMATION_REQUEST_NEG_REPLY_T_PDU();
    case HCI_ULP_ENCRYPT :
        return new HCI_ULP_ENCRYPT_T_PDU();
    case HCI_READ_AFH_CHANNEL_CLASS_M :
        return new HCI_READ_AFH_CHANNEL_CLASS_M_T_PDU();
    case HCI_WRITE_HOLD_MODE_ACTIVITY :
        return new HCI_WRITE_HOLD_MODE_ACTIVITY_T_PDU();
    case HCI_WRITE_INQUIRY_TRANSMIT_POWER_LEVEL :
        return new HCI_WRITE_INQUIRY_TRANSMIT_POWER_LEVEL_T_PDU();
    case HCI_READ_SCAN_ENABLE :
        return new HCI_READ_SCAN_ENABLE_T_PDU();
    case HCI_READ_ENCRYPTION_KEY_SIZE :
        return new HCI_READ_ENCRYPTION_KEY_SIZE_T_PDU();
    case HCI_WRITE_LINK_POLICY_SETTINGS :
        return new HCI_WRITE_LINK_POLICY_SETTINGS_T_PDU();
    case HCI_READ_ALIAS_AUTH_ENABLE :
        return new HCI_READ_ALIAS_AUTH_ENABLE_T_PDU();
    case HCI_PIN_CODE_REQ_REPLY :
        return new HCI_PIN_CODE_REQ_REPLY_T_PDU();
    case HCI_CREATE_NEW_UNIT_KEY :
        return new HCI_CREATE_NEW_UNIT_KEY_T_PDU();
    case HCI_WRITE_PAGESCAN_MODE :
        return new HCI_WRITE_PAGESCAN_MODE_T_PDU();
    case HCI_WRITE_EXTENDED_INQUIRY_RESPONSE_DATA :
        return new HCI_WRITE_EXTENDED_INQUIRY_RESPONSE_DATA_T_PDU();
    case HCI_EXIT_SNIFF_MODE :
        return new HCI_EXIT_SNIFF_MODE_T_PDU();
    case HCI_READ_LOOPBACK_MODE :
        return new HCI_READ_LOOPBACK_MODE_T_PDU();
    case HCI_READ_EXTENDED_INQUIRY_RESPONSE_DATA :
        return new HCI_READ_EXTENDED_INQUIRY_RESPONSE_DATA_T_PDU();
    case HCI_READ_FAILED_CONTACT_COUNT :
        return new HCI_READ_FAILED_CONTACT_COUNT_T_PDU();
    case HCI_SNIFF_SUB_RATE :
        return new HCI_SNIFF_SUB_RATE_T_PDU();
    case HCI_READ_ANON_MODE :
        return new HCI_READ_ANON_MODE_T_PDU();
    case HCI_ULP_SET_SCAN_PARAMETERS :
        return new HCI_ULP_SET_SCAN_PARAMETERS_T_PDU();
    case HCI_WRITE_SIMPLE_PAIRING_DEBUG_MODE :
        return new HCI_WRITE_SIMPLE_PAIRING_DEBUG_MODE_T_PDU();
    case HCI_READ_AUTO_FLUSH_TIMEOUT :
        return new HCI_READ_AUTO_FLUSH_TIMEOUT_T_PDU();
    case HCI_REMOTE_OOB_DATA_REQUEST_NEG_REPLY :
        return new HCI_REMOTE_OOB_DATA_REQUEST_NEG_REPLY_T_PDU();
    case HCI_DELETE_STORED_LINK_KEY :
        return new HCI_DELETE_STORED_LINK_KEY_T_PDU();
    case HCI_WRITE_CLASS_OF_DEVICE :
        return new HCI_WRITE_CLASS_OF_DEVICE_T_PDU();
    case HCI_WRITE_PIN_TYPE :
        return new HCI_WRITE_PIN_TYPE_T_PDU();
    case HCI_EXIT_PARK_MODE :
        return new HCI_EXIT_PARK_MODE_T_PDU();
    case HCI_ULP_SET_ADVERTISE_ENABLE :
        return new HCI_ULP_SET_ADVERTISE_ENABLE_T_PDU();
    case HCI_QOS_SETUP :
        return new HCI_QOS_SETUP_T_PDU();
    case HCI_WRITE_PAGESCAN_ACTIVITY :
        return new HCI_WRITE_PAGESCAN_ACTIVITY_T_PDU();
    case HCI_READ_VOICE_SETTING :
        return new HCI_READ_VOICE_SETTING_T_PDU();
    case HCI_PARK_MODE :
        return new HCI_PARK_MODE_T_PDU();
    case HCI_READ_COUNTRY_CODE :
        return new HCI_READ_COUNTRY_CODE_T_PDU();
    case HCI_SET_EVENT_MASK :
        return new HCI_SET_EVENT_MASK_T_PDU();
    case HCI_HOLD_MODE :
        return new HCI_HOLD_MODE_T_PDU();
    case HCI_READ_AUTH_ENABLE :
        return new HCI_READ_AUTH_ENABLE_T_PDU();
    case HCI_READ_LOCAL_OOB_DATA :
        return new HCI_READ_LOCAL_OOB_DATA_T_PDU();
    case HCI_WRITE_DEFAULT_LINK_POLICY_SETTINGS :
        return new HCI_WRITE_DEFAULT_LINK_POLICY_SETTINGS_T_PDU();
    case HCI_READ_PAGESCAN_ACTIVITY :
        return new HCI_READ_PAGESCAN_ACTIVITY_T_PDU();
    case HCI_WRITE_CURRENT_IAC_LAP :
        return new HCI_WRITE_CURRENT_IAC_LAP_T_PDU();
    case HCI_ACCEPT_CONNECTION_REQ :
        return new HCI_ACCEPT_CONNECTION_REQ_T_PDU();
    case HCI_ULP_READ_LOCAL_SUPPORTED_FEATURES :
        return new HCI_ULP_READ_LOCAL_SUPPORTED_FEATURES_T_PDU();
    case HCI_READ_TX_POWER_LEVEL :
        return new HCI_READ_TX_POWER_LEVEL_T_PDU();
    case HCI_WRITE_LINK_SUPERV_TIMEOUT :
        return new HCI_WRITE_LINK_SUPERV_TIMEOUT_T_PDU();
    case HCI_AUTH_REQ :
        return new HCI_AUTH_REQ_T_PDU();
    case HCI_INQUIRY_CANCEL :
        return new HCI_INQUIRY_CANCEL_T_PDU();
    case HCI_WRITE_INQUIRYSCAN_ACTIVITY :
        return new HCI_WRITE_INQUIRYSCAN_ACTIVITY_T_PDU();
    case HCI_READ_NUM_BCAST_RETXS :
        return new HCI_READ_NUM_BCAST_RETXS_T_PDU();
    case HCI_READ_AFH_CHANNEL_MAP :
        return new HCI_READ_AFH_CHANNEL_MAP_T_PDU();
    case HCI_USER_PASSKEY_REQUEST_REPLY :
        return new HCI_USER_PASSKEY_REQUEST_REPLY_T_PDU();
    case HCI_WRITE_PAGESCAN_PERIOD_MODE :
        return new HCI_WRITE_PAGESCAN_PERIOD_MODE_T_PDU();
    case HCI_READ_LE_HOST_SUPPORT :
        return new HCI_READ_LE_HOST_SUPPORT_T_PDU();
    case HCI_READ_LINK_SUPERV_TIMEOUT :
        return new HCI_READ_LINK_SUPERV_TIMEOUT_T_PDU();
    case HCI_EXCHANGE_ALIAS_INFO :
        return new HCI_EXCHANGE_ALIAS_INFO_T_PDU();
    case HCI_ULP_SET_SCAN_RESPONSE_DATA :
        return new HCI_ULP_SET_SCAN_RESPONSE_DATA_T_PDU();
    case HCI_WRITE_CONN_ACCEPT_TIMEOUT :
        return new HCI_WRITE_CONN_ACCEPT_TIMEOUT_T_PDU();
    case HCI_RESET_FAILED_CONTACT_COUNT :
        return new HCI_RESET_FAILED_CONTACT_COUNT_T_PDU();
    case HCI_WRITE_LOOPBACK_MODE :
        return new HCI_WRITE_LOOPBACK_MODE_T_PDU();
    case HCI_READ_ANON_ADDR_CHANGE_PARAMS :
        return new HCI_READ_ANON_ADDR_CHANGE_PARAMS_T_PDU();
    case HCI_ULP_CREATE_CONNECTION :
        return new HCI_ULP_CREATE_CONNECTION_T_PDU();
    case HCI_READ_LOCAL_SUPP_FEATURES :
        return new HCI_READ_LOCAL_SUPP_FEATURES_T_PDU();
    case HCI_READ_RSSI :
        return new HCI_READ_RSSI_T_PDU();
    case HCI_EXIT_PERIODIC_INQUIRY_MODE :
        return new HCI_EXIT_PERIODIC_INQUIRY_MODE_T_PDU();
    case HCI_ULP_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY :
        return new HCI_ULP_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY_T_PDU();
    case HCI_ACCEPT_SYNCHRONOUS_CONN_REQ :
        return new HCI_ACCEPT_SYNCHRONOUS_CONN_REQ_T_PDU();
    case HCI_WRITE_ENC_MODE :
        return new HCI_WRITE_ENC_MODE_T_PDU();
    case HCI_READ_CONN_ACCEPT_TIMEOUT :
        return new HCI_READ_CONN_ACCEPT_TIMEOUT_T_PDU();
    case HCI_IO_CAPABILITY_REQUEST_NEG_REPLY :
        return new HCI_IO_CAPABILITY_REQUEST_NEG_REPLY_T_PDU();
    case HCI_ENABLE_DUT_MODE :
        return new HCI_ENABLE_DUT_MODE_T_PDU();
    case HCI_ULP_READ_SUPPORTED_STATES :
        return new HCI_ULP_READ_SUPPORTED_STATES_T_PDU();
    case HCI_GET_LINK_QUALITY :
        return new HCI_GET_LINK_QUALITY_T_PDU();
    case HCI_CHANGE_CONN_PKT_TYPE :
        return new HCI_CHANGE_CONN_PKT_TYPE_T_PDU();
    case HCI_WRITE_VOICE_SETTING :
        return new HCI_WRITE_VOICE_SETTING_T_PDU();
    case HCI_READ_ENH_TX_POWER_LEVEL :
        return new HCI_READ_ENH_TX_POWER_LEVEL_T_PDU();
    case HCI_ULP_SET_RANDOM_ADDRESS :
        return new HCI_ULP_SET_RANDOM_ADDRESS_T_PDU();
    case HCI_READ_CLOCK_OFFSET :
        return new HCI_READ_CLOCK_OFFSET_T_PDU();
    case HCI_REMOTE_NAME_REQ_CANCEL :
        return new HCI_REMOTE_NAME_REQ_CANCEL_T_PDU();
    case HCI_WRITE_STORED_LINK_KEY :
        return new HCI_WRITE_STORED_LINK_KEY_T_PDU();
    case HCI_ULP_RECEIVER_TEST :
        return new HCI_ULP_RECEIVER_TEST_T_PDU();
    case HCI_ULP_READ_BUFFER_SIZE :
        return new HCI_ULP_READ_BUFFER_SIZE_T_PDU();
    case HCI_USER_PASSKEY_REQUEST_NEG_REPLY :
        return new HCI_USER_PASSKEY_REQUEST_NEG_REPLY_T_PDU();
    case HCI_LINK_KEY_REQ_NEG_REPLY :
        return new HCI_LINK_KEY_REQ_NEG_REPLY_T_PDU();
    case HCI_READ_LOCAL_EXT_FEATURES :
        return new HCI_READ_LOCAL_EXT_FEATURES_T_PDU();
    case HCI_READ_CLASS_OF_DEVICE :
        return new HCI_READ_CLASS_OF_DEVICE_T_PDU();
    case HCI_ULP_REMOVE_DEVICE_FROM_WHITE_LIST :
        return new HCI_ULP_REMOVE_DEVICE_FROM_WHITE_LIST_T_PDU();
    case HCI_READ_BUFFER_SIZE :
        return new HCI_READ_BUFFER_SIZE_T_PDU();
    case HCI_ULP_READ_REMOTE_USED_FEATURES :
        return new HCI_ULP_READ_REMOTE_USED_FEATURES_T_PDU();
    case HCI_RESET_FIXED_ADDRESS_ATTEMPTS_COUNTER :
        return new HCI_RESET_FIXED_ADDRESS_ATTEMPTS_COUNTER_T_PDU();
    case HCI_FLOW_SPEC :
        return new HCI_FLOW_SPEC_T_PDU();
    case HCI_ULP_SET_EVENT_MASK :
        return new HCI_ULP_SET_EVENT_MASK_T_PDU();
    case HCI_SET_HCTOHOST_FLOW_CONTROL :
        return new HCI_SET_HCTOHOST_FLOW_CONTROL_T_PDU();
    case HCI_WRITE_SCAN_ENABLE :
        return new HCI_WRITE_SCAN_ENABLE_T_PDU();
    case HCI_ULP_READ_CHANNEL_MAP :
        return new HCI_ULP_READ_CHANNEL_MAP_T_PDU();
    case HCI_SNIFF_MODE :
        return new HCI_SNIFF_MODE_T_PDU();
    case HCI_READ_LOCAL_SUPP_COMMANDS :
        return new HCI_READ_LOCAL_SUPP_COMMANDS_T_PDU();
    case HCI_REJECT_CONNECTION_REQ :
        return new HCI_REJECT_CONNECTION_REQ_T_PDU();
    case HCI_ULP_SET_ADVERTISING_PARAMETERS :
        return new HCI_ULP_SET_ADVERTISING_PARAMETERS_T_PDU();
    case HCI_WRITE_ANON_ADDR_CHANGE_PARAMS :
        return new HCI_WRITE_ANON_ADDR_CHANGE_PARAMS_T_PDU();
    case HCI_CREATE_CONNECTION :
        return new HCI_CREATE_CONNECTION_T_PDU();
    case HCI_READ_CURRENT_IAC_LAP :
        return new HCI_READ_CURRENT_IAC_LAP_T_PDU();
    case HCI_READ_HOLD_MODE_ACTIVITY :
        return new HCI_READ_HOLD_MODE_ACTIVITY_T_PDU();
    case HCI_CHANGE_LOCAL_NAME :
        return new HCI_CHANGE_LOCAL_NAME_T_PDU();
    case HCI_ULP_SET_ADVERTISING_DATA :
        return new HCI_ULP_SET_ADVERTISING_DATA_T_PDU();
    case HCI_READ_INQUIRY_MODE :
        return new HCI_READ_INQUIRY_MODE_T_PDU();
    case HCI_READ_PAGE_TIMEOUT :
        return new HCI_READ_PAGE_TIMEOUT_T_PDU();
    default:
		return 0;
    }
} // end createHCIComandPDU

HCIPDU * HCIPDUFactory::createCommandPDU( uint32 * parameters )
{
    HCIPDU * prim = 0;

    if ( parameters && ( parameters[0] >= 2 ) )
    {
        HCICommandPDU * pdu = createHCIComandPDU((uint16)parameters[1]);
		if ( pdu && pdu->build(parameters) )
			prim = pdu;
    }
    return prim ;
}

// end of part generated by cmd_switch.tpl
// start of part generated from cmd_build.tpl 

#include <cassert>
#include "cmd_build_fields.h"

bool HCI_READ_LMP_HANDLE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_LMP_HANDLE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_REJECT_SYNCHRONOUS_CONN_REQ_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_REJECT_SYNCHRONOUS_CONN_REQ == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set reason
    if ( ptr < end )
        set_reason ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ADD_SCO_CONNECTION_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ADD_SCO_CONNECTION == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set pkt_type
    if ( ptr < end )
        set_pkt_type ( (uint16)(*ptr++) );
    return true;
}

bool HCI_WRITE_ANON_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_ANON_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set mode
    if ( ptr < end )
        set_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_SEND_KEYPRESS_NOTIFICATION_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_SEND_KEYPRESS_NOTIFICATION == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set notification_type
    if ( ptr < end )
        set_notification_type ( (uint8)(*ptr++) );
    return true;
}

bool HCI_CHANGE_CONN_LINK_KEY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_CHANGE_CONN_LINK_KEY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_ALIAS_ADDRESS_REQ_NEG_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ALIAS_ADDRESS_REQ_NEG_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_WRITE_AUTO_FLUSH_TIMEOUT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_AUTO_FLUSH_TIMEOUT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set timeout
    if ( ptr < end )
        set_timeout ( (uint16)(*ptr++) );
    return true;
}

bool HCI_WRITE_SCO_FLOW_CON_ENABLE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_SCO_FLOW_CON_ENABLE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set sco_flow_control_enable
    if ( ptr < end )
        set_sco_flow_control_enable ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_AUTH_ENABLE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_AUTH_ENABLE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set auth_enable
    if ( ptr < end )
        set_auth_enable ( (uint8)(*ptr++) );
    return true;
}

bool HCI_READ_LINK_POLICY_SETTINGS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_LINK_POLICY_SETTINGS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_READ_STORED_LINK_KEY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_STORED_LINK_KEY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set read_all
    if ( ptr < end )
        set_read_all ( (uint8)(*ptr++) );
    return true;
}

bool HCI_SWITCH_ROLE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_SWITCH_ROLE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set role
    if ( ptr < end )
        set_role ( (uint8)(*ptr++) );
    return true;
}

bool HCI_INQUIRY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_INQUIRY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 5 fields
    // set lap
    if ( ptr < end )
        set_lap ( (uint24)(*ptr++) );
    // set inquiry_length
    if ( ptr < end )
        set_inquiry_length ( (uint8)(*ptr++) );
    // set num_responses
    if ( ptr < end )
        set_num_responses ( (uint8)(*ptr++) );
    return true;
}

bool HCI_READ_REMOTE_EXT_FEATURES_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_REMOTE_EXT_FEATURES == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set page_num
    if ( ptr < end )
        set_page_num ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ULP_TRANSMITTER_TEST_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_TRANSMITTER_TEST == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 5 fields
    // set tx_channel
    if ( ptr < end )
        set_tx_channel ( (uint8)(*ptr++) );
    // set length_test_data
    if ( ptr < end )
        set_length_test_data ( (uint8)(*ptr++) );
    // set packet_payload
    if ( ptr < end )
        set_packet_payload ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_INQUIRY_SCAN_TYPE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_INQUIRY_SCAN_TYPE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set mode
    if ( ptr < end )
        set_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_REFRESH_ENCRYPTION_KEY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_REFRESH_ENCRYPTION_KEY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_EXCHANGE_FIXED_INFO_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_EXCHANGE_FIXED_INFO == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_SETUP_SYNCHRONOUS_CONN_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_SETUP_SYNCHRONOUS_CONN == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 9 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set tx_bdw
    if ( ptr < end )
        set_tx_bdw ( (uint32)(*ptr++) );
    // set rx_bdw
    if ( ptr < end )
        set_rx_bdw ( (uint32)(*ptr++) );
    // set max_latency
    if ( ptr < end )
        set_max_latency ( (uint16)(*ptr++) );
    // set voice_settings
    if ( ptr < end )
        set_voice_settings ( (uint16)(*ptr++) );
    // set retx_effort
    if ( ptr < end )
        set_retx_effort ( (uint8)(*ptr++) );
    // set pkt_type
    if ( ptr < end )
        set_pkt_type ( (uint16)(*ptr++) );
    return true;
}

bool HCI_FLUSH_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_FLUSH == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_ULP_START_ENCRYPTION_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_START_ENCRYPTION == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 6 fields
    // set connection_handle
    if ( ptr < end )
        set_connection_handle ( (uint16)(*ptr++) );
    // set random_number
    build_random_number(*this, parameters, &ptr, end);
    // set encrypted_diversifier
    if ( ptr < end )
        set_encrypted_diversifier ( (uint16)(*ptr++) );
    // set long_term_key
    build_long_term_key(*this, parameters, &ptr, end);
    return true;
}

bool HCI_ULP_SET_SCAN_ENABLE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_SET_SCAN_ENABLE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set scan_enable
    if ( ptr < end )
        set_scan_enable ( (uint8)(*ptr++) );
    // set filter_duplicates
    if ( ptr < end )
        set_filter_duplicates ( (uint8)(*ptr++) );
    return true;
}

bool HCI_SET_AFH_CHANNEL_CLASS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_SET_AFH_CHANNEL_CLASS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set map
    build_map(*this, parameters, &ptr, end);
    return true;
}

bool HCI_IO_CAPABILITY_RESPONSE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_IO_CAPABILITY_RESPONSE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 6 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set io_capability
    if ( ptr < end )
        set_io_capability ( (uint8)(*ptr++) );
    // set oob_data_present
    if ( ptr < end )
        set_oob_data_present ( (uint8)(*ptr++) );
    // set authentication_requirements
    if ( ptr < end )
        set_authentication_requirements ( (uint8)(*ptr++) );
    return true;
}

bool HCI_SET_CONN_ENCRYPTION_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_SET_CONN_ENCRYPTION == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set enc_enable
    if ( ptr < end )
        set_enc_enable ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ULP_LONG_TERM_KEY_REQUESTED_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_LONG_TERM_KEY_REQUESTED_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set connection_handle
    if ( ptr < end )
        set_connection_handle ( (uint16)(*ptr++) );
    // set long_term_key
    build_long_term_key(*this, parameters, &ptr, end);
    return true;
}

bool HCI_HOST_NUM_COMPLETED_PACKETS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_HOST_NUM_COMPLETED_PACKETS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set num_handles
    if ( ptr < end )
        set_num_handles ( (uint8)(*ptr++) );
    // set num_completed_pkts_ptr
    build_num_completed_pkts_ptr(*this, parameters, &ptr, end);
    return true;
}

bool HCI_READ_REMOTE_SUPP_FEATURES_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_REMOTE_SUPP_FEATURES == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_READ_REMOTE_VER_INFO_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_REMOTE_VER_INFO == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_HOST_BUFFER_SIZE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_HOST_BUFFER_SIZE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 6 fields
    // set acl_packet_len
    if ( ptr < end )
        set_acl_packet_len ( (uint16)(*ptr++) );
    // set sco_packet_len
    if ( ptr < end )
        set_sco_packet_len ( (uint8)(*ptr++) );
    // set acl_total_packets
    if ( ptr < end )
        set_acl_total_packets ( (uint16)(*ptr++) );
    // set sco_total_packets
    if ( ptr < end )
        set_sco_total_packets ( (uint16)(*ptr++) );
    return true;
}

bool HCI_ALIAS_ADDRESS_REQ_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ALIAS_ADDRESS_REQ_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set bd_addr_alias
    if ( ptr + 3 <= end )
    {
        set_bd_addr_alias ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_WRITE_SIMPLE_PAIRING_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_SIMPLE_PAIRING_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set simple_pairing_mode
    if ( ptr < end )
        set_simple_pairing_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ULP_CONNECTION_UPDATE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_CONNECTION_UPDATE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 9 fields
    // set connection_handle
    if ( ptr < end )
        set_connection_handle ( (uint16)(*ptr++) );
    // set conn_interval_min
    if ( ptr < end )
        set_conn_interval_min ( (uint16)(*ptr++) );
    // set conn_interval_max
    if ( ptr < end )
        set_conn_interval_max ( (uint16)(*ptr++) );
    // set conn_latency
    if ( ptr < end )
        set_conn_latency ( (uint16)(*ptr++) );
    // set supervision_timeout
    if ( ptr < end )
        set_supervision_timeout ( (uint16)(*ptr++) );
    // set minimum_ce_length
    if ( ptr < end )
        set_minimum_ce_length ( (uint16)(*ptr++) );
    // set maximum_ce_length
    if ( ptr < end )
        set_maximum_ce_length ( (uint16)(*ptr++) );
    return true;
}

bool HCI_READ_CLOCK_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_CLOCK == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set which_clock
    if ( ptr < end )
        set_which_clock ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ENHANCED_FLUSH_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ENHANCED_FLUSH == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set pkt_type
    if ( ptr < end )
        set_pkt_type ( (uint8)(*ptr++) );
    return true;
}

bool HCI_PERIODIC_INQUIRY_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_PERIODIC_INQUIRY_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 7 fields
    // set max_period_length
    if ( ptr < end )
        set_max_period_length ( (uint16)(*ptr++) );
    // set min_period_length
    if ( ptr < end )
        set_min_period_length ( (uint16)(*ptr++) );
    // set lap
    if ( ptr < end )
        set_lap ( (uint24)(*ptr++) );
    // set inquiry_length
    if ( ptr < end )
        set_inquiry_length ( (uint8)(*ptr++) );
    // set num_responses
    if ( ptr < end )
        set_num_responses ( (uint8)(*ptr++) );
    return true;
}

bool HCI_MNFR_EXTENSION_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_MNFR_EXTENSION == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set payload_descriptor
    if ( ptr < end )
        set_payload_descriptor ( (uint8)(*ptr++) );
    // set payload
    build_payload(*this, parameters, &ptr, end);
    return true;
}

bool HCI_ROLE_DISCOVERY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ROLE_DISCOVERY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_PRIVATE_PAIRING_REQ_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_PRIVATE_PAIRING_REQ_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_WRITE_INQUIRY_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_INQUIRY_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set mode
    if ( ptr < end )
        set_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_USER_CONFIRMATION_REQUEST_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_USER_CONFIRMATION_REQUEST_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_WRITE_PAGE_TIMEOUT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_PAGE_TIMEOUT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set page_timeout
    if ( ptr < end )
        set_page_timeout ( (uint16)(*ptr++) );
    return true;
}

bool HCI_ULP_ADD_DEVICE_TO_WHITE_LIST_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_ADD_DEVICE_TO_WHITE_LIST == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set address_type
    if ( ptr < end )
        set_address_type ( (uint8)(*ptr++) );
    // set address
    if ( ptr + 3 <= end )
    {
        set_address ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_WRITE_PAGE_SCAN_TYPE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_PAGE_SCAN_TYPE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set mode
    if ( ptr < end )
        set_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_REMOTE_NAME_REQ_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_REMOTE_NAME_REQ == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 6 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set page_scan_rep_mode
    if ( ptr < end )
        set_page_scan_rep_mode ( (uint8)(*ptr++) );
    // set page_scan_mode
    if ( ptr < end )
        set_page_scan_mode ( (uint8)(*ptr++) );
    // set clock_offset
    if ( ptr < end )
        set_clock_offset ( (uint16)(*ptr++) );
    return true;
}

bool HCI_CREATE_CONNECTION_CANCEL_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_CREATE_CONNECTION_CANCEL == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_REMOTE_OOB_DATA_REQUEST_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_REMOTE_OOB_DATA_REQUEST_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 5 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set c
    build_c(*this, parameters, &ptr, end);
    // set r
    build_r(*this, parameters, &ptr, end);
    return true;
}

bool HCI_DISCONNECT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_DISCONNECT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set reason
    if ( ptr < end )
        set_reason ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_AFH_CHANNEL_CLASS_M_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_AFH_CHANNEL_CLASS_M == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set class_mode
    if ( ptr < end )
        set_class_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ULP_SET_HOST_CHANNEL_CLASSIFICATION_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_SET_HOST_CHANNEL_CLASSIFICATION == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set channel_map
    build_channel_map(*this, parameters, &ptr, end);
    return true;
}

bool HCI_GENERATED_ALIAS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_GENERATED_ALIAS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set bd_addr_alias
    if ( ptr + 3 <= end )
    {
        set_bd_addr_alias ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_PRIVATE_PAIRING_REQ_NEG_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_PRIVATE_PAIRING_REQ_NEG_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_LINK_KEY_REQ_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_LINK_KEY_REQ_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set key_val
    build_key_val(*this, parameters, &ptr, end);
    return true;
}

bool HCI_WRITE_NUM_BCAST_RETXS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_NUM_BCAST_RETXS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set num
    if ( ptr < end )
        set_num ( (uint8)(*ptr++) );
    return true;
}

bool HCI_PIN_CODE_REQ_NEG_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_PIN_CODE_REQ_NEG_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_WRITE_ALIAS_AUTH_ENABLE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_ALIAS_AUTH_ENABLE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set enable
    if ( ptr < end )
        set_enable ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_LE_HOST_SUPPORT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_LE_HOST_SUPPORT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set le_supported_host
    if ( ptr < end )
        set_le_supported_host ( (uint8)(*ptr++) );
    // set simultaneous_le_host
    if ( ptr < end )
        set_simultaneous_le_host ( (uint8)(*ptr++) );
    return true;
}

bool HCI_MASTER_LINK_KEY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_MASTER_LINK_KEY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set link_key_type
    if ( ptr < end )
        set_link_key_type ( (uint8)(*ptr++) );
    return true;
}

bool HCI_USER_CONFIRMATION_REQUEST_NEG_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_USER_CONFIRMATION_REQUEST_NEG_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_ULP_ENCRYPT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_ENCRYPT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set aes_key
    build_aes_key(*this, parameters, &ptr, end);
    // set plaintext_data
    build_plaintext_data(*this, parameters, &ptr, end);
    return true;
}

bool HCI_WRITE_HOLD_MODE_ACTIVITY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_HOLD_MODE_ACTIVITY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set activity
    if ( ptr < end )
        set_activity ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_INQUIRY_TRANSMIT_POWER_LEVEL_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_INQUIRY_TRANSMIT_POWER_LEVEL == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set tx_power
    if ( ptr < end )
        set_tx_power ( (int8)(*ptr++) );
    return true;
}

bool HCI_READ_ENCRYPTION_KEY_SIZE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_ENCRYPTION_KEY_SIZE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_WRITE_LINK_POLICY_SETTINGS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_LINK_POLICY_SETTINGS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set link_policy_settings
    if ( ptr < end )
        set_link_policy_settings ( (uint16)(*ptr++) );
    return true;
}

bool HCI_PIN_CODE_REQ_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_PIN_CODE_REQ_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 5 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set pin_code_length
    if ( ptr < end )
        set_pin_code_length ( (uint8)(*ptr++) );
    // set pin
    build_pin(*this, parameters, &ptr, end);
    return true;
}

bool HCI_WRITE_PAGESCAN_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_PAGESCAN_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set mode
    if ( ptr < end )
        set_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_EXTENDED_INQUIRY_RESPONSE_DATA_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_EXTENDED_INQUIRY_RESPONSE_DATA == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set fec_required
    if ( ptr < end )
        set_fec_required ( (uint8)(*ptr++) );
    // set eir_data_part
    build_eir_data_part(*this, parameters, &ptr, end);
    return true;
}

bool HCI_EXIT_SNIFF_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_EXIT_SNIFF_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_READ_FAILED_CONTACT_COUNT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_FAILED_CONTACT_COUNT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_SNIFF_SUB_RATE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_SNIFF_SUB_RATE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 6 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set max_remote_latency
    if ( ptr < end )
        set_max_remote_latency ( (uint16)(*ptr++) );
    // set min_remote_timeout
    if ( ptr < end )
        set_min_remote_timeout ( (uint16)(*ptr++) );
    // set min_local_timeout
    if ( ptr < end )
        set_min_local_timeout ( (uint16)(*ptr++) );
    return true;
}

bool HCI_ULP_SET_SCAN_PARAMETERS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_SET_SCAN_PARAMETERS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 7 fields
    // set scan_type
    if ( ptr < end )
        set_scan_type ( (uint8)(*ptr++) );
    // set scan_interval
    if ( ptr < end )
        set_scan_interval ( (uint16)(*ptr++) );
    // set scan_window
    if ( ptr < end )
        set_scan_window ( (uint16)(*ptr++) );
    // set own_address_type
    if ( ptr < end )
        set_own_address_type ( (uint8)(*ptr++) );
    // set scanning_filter_policy
    if ( ptr < end )
        set_scanning_filter_policy ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_SIMPLE_PAIRING_DEBUG_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_SIMPLE_PAIRING_DEBUG_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set simple_pairing_debug_mode
    if ( ptr < end )
        set_simple_pairing_debug_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_READ_AUTO_FLUSH_TIMEOUT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_AUTO_FLUSH_TIMEOUT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_REMOTE_OOB_DATA_REQUEST_NEG_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_REMOTE_OOB_DATA_REQUEST_NEG_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_DELETE_STORED_LINK_KEY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_DELETE_STORED_LINK_KEY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set flag
    if ( ptr < end )
        set_flag ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_CLASS_OF_DEVICE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_CLASS_OF_DEVICE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set dev_class
    if ( ptr < end )
        set_dev_class ( (uint24)(*ptr++) );
    return true;
}

bool HCI_WRITE_PIN_TYPE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_PIN_TYPE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set pin_type
    if ( ptr < end )
        set_pin_type ( (uint8)(*ptr++) );
    return true;
}

bool HCI_EXIT_PARK_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_EXIT_PARK_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_ULP_SET_ADVERTISE_ENABLE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_SET_ADVERTISE_ENABLE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set advertising_enable
    if ( ptr < end )
        set_advertising_enable ( (uint8)(*ptr++) );
    return true;
}

bool HCI_QOS_SETUP_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_QOS_SETUP == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 9 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set flags
    if ( ptr < end )
        set_flags ( (uint8)(*ptr++) );
    // set service_type
    if ( ptr < end )
        set_service_type ( (uint8)(*ptr++) );
    // set token_rate
    if ( ptr < end )
        set_token_rate ( (uint32)(*ptr++) );
    // set peak_bandwidth
    if ( ptr < end )
        set_peak_bandwidth ( (uint32)(*ptr++) );
    // set latency
    if ( ptr < end )
        set_latency ( (uint32)(*ptr++) );
    // set delay_variation
    if ( ptr < end )
        set_delay_variation ( (uint32)(*ptr++) );
    return true;
}

bool HCI_WRITE_PAGESCAN_ACTIVITY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_PAGESCAN_ACTIVITY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set pagescan_interval
    if ( ptr < end )
        set_pagescan_interval ( (uint16)(*ptr++) );
    // set pagescan_window
    if ( ptr < end )
        set_pagescan_window ( (uint16)(*ptr++) );
    return true;
}

bool HCI_PARK_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_PARK_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 5 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set max_interval
    if ( ptr < end )
        set_max_interval ( (uint16)(*ptr++) );
    // set min_interval
    if ( ptr < end )
        set_min_interval ( (uint16)(*ptr++) );
    return true;
}

bool HCI_SET_EVENT_MASK_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_SET_EVENT_MASK == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set event_mask
    build_event_mask(*this, parameters, &ptr, end);
    return true;
}

bool HCI_HOLD_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_HOLD_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 5 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set max_interval
    if ( ptr < end )
        set_max_interval ( (uint16)(*ptr++) );
    // set min_interval
    if ( ptr < end )
        set_min_interval ( (uint16)(*ptr++) );
    return true;
}

bool HCI_WRITE_DEFAULT_LINK_POLICY_SETTINGS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_DEFAULT_LINK_POLICY_SETTINGS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set default_lps
    if ( ptr < end )
        set_default_lps ( (uint16)(*ptr++) );
    return true;
}

bool HCI_WRITE_CURRENT_IAC_LAP_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_CURRENT_IAC_LAP == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set num_current_iac
    if ( ptr < end )
        set_num_current_iac ( (uint8)(*ptr++) );
    // set iac_lap
    build_iac_lap(*this, parameters, &ptr, end);
    return true;
}

bool HCI_ACCEPT_CONNECTION_REQ_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ACCEPT_CONNECTION_REQ == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set role
    if ( ptr < end )
        set_role ( (uint8)(*ptr++) );
    return true;
}

bool HCI_READ_TX_POWER_LEVEL_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_TX_POWER_LEVEL == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set type
    if ( ptr < end )
        set_type ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_LINK_SUPERV_TIMEOUT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_LINK_SUPERV_TIMEOUT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set timeout
    if ( ptr < end )
        set_timeout ( (uint16)(*ptr++) );
    return true;
}

bool HCI_AUTH_REQ_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_AUTH_REQ == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_WRITE_INQUIRYSCAN_ACTIVITY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_INQUIRYSCAN_ACTIVITY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set inqscan_interval
    if ( ptr < end )
        set_inqscan_interval ( (uint16)(*ptr++) );
    // set inqscan_window
    if ( ptr < end )
        set_inqscan_window ( (uint16)(*ptr++) );
    return true;
}

bool HCI_READ_AFH_CHANNEL_MAP_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_AFH_CHANNEL_MAP == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_USER_PASSKEY_REQUEST_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_USER_PASSKEY_REQUEST_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set numeric_value
    if ( ptr < end )
        set_numeric_value ( (uint32)(*ptr++) );
    return true;
}

bool HCI_WRITE_PAGESCAN_PERIOD_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_PAGESCAN_PERIOD_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set mode
    if ( ptr < end )
        set_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_READ_LINK_SUPERV_TIMEOUT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_LINK_SUPERV_TIMEOUT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_EXCHANGE_ALIAS_INFO_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_EXCHANGE_ALIAS_INFO == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set local_alias_addr
    if ( ptr + 3 <= end )
    {
        set_local_alias_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_ULP_SET_SCAN_RESPONSE_DATA_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_SET_SCAN_RESPONSE_DATA == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set scan_response_data_len
    if ( ptr < end )
        set_scan_response_data_len ( (uint8)(*ptr++) );
    // set scan_response_data
    build_scan_response_data(*this, parameters, &ptr, end);
    return true;
}

bool HCI_WRITE_CONN_ACCEPT_TIMEOUT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_CONN_ACCEPT_TIMEOUT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set conn_accept_timeout
    if ( ptr < end )
        set_conn_accept_timeout ( (uint16)(*ptr++) );
    return true;
}

bool HCI_RESET_FAILED_CONTACT_COUNT_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_RESET_FAILED_CONTACT_COUNT == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_WRITE_LOOPBACK_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_LOOPBACK_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set mode
    if ( ptr < end )
        set_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ULP_CREATE_CONNECTION_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_CREATE_CONNECTION == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 14 fields
    // set scan_interval
    if ( ptr < end )
        set_scan_interval ( (uint16)(*ptr++) );
    // set scan_window
    if ( ptr < end )
        set_scan_window ( (uint16)(*ptr++) );
    // set initiator_filter_policy
    if ( ptr < end )
        set_initiator_filter_policy ( (uint8)(*ptr++) );
    // set peer_address_type
    if ( ptr < end )
        set_peer_address_type ( (uint8)(*ptr++) );
    // set peer_address
    if ( ptr + 3 <= end )
    {
        set_peer_address ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set own_address_type
    if ( ptr < end )
        set_own_address_type ( (uint8)(*ptr++) );
    // set conn_interval_min
    if ( ptr < end )
        set_conn_interval_min ( (uint16)(*ptr++) );
    // set conn_interval_max
    if ( ptr < end )
        set_conn_interval_max ( (uint16)(*ptr++) );
    // set conn_latency
    if ( ptr < end )
        set_conn_latency ( (uint16)(*ptr++) );
    // set supervision_timeout
    if ( ptr < end )
        set_supervision_timeout ( (uint16)(*ptr++) );
    // set minimum_ce_length
    if ( ptr < end )
        set_minimum_ce_length ( (uint16)(*ptr++) );
    // set maximum_ce_length
    if ( ptr < end )
        set_maximum_ce_length ( (uint16)(*ptr++) );
    return true;
}

bool HCI_READ_RSSI_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_RSSI == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_ULP_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set connection_handle
    if ( ptr < end )
        set_connection_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_ACCEPT_SYNCHRONOUS_CONN_REQ_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ACCEPT_SYNCHRONOUS_CONN_REQ == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 9 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set tx_bdw
    if ( ptr < end )
        set_tx_bdw ( (uint32)(*ptr++) );
    // set rx_bdw
    if ( ptr < end )
        set_rx_bdw ( (uint32)(*ptr++) );
    // set max_latency
    if ( ptr < end )
        set_max_latency ( (uint16)(*ptr++) );
    // set voice_settings
    if ( ptr < end )
        set_voice_settings ( (uint16)(*ptr++) );
    // set retx_effort
    if ( ptr < end )
        set_retx_effort ( (uint8)(*ptr++) );
    // set pkt_type
    if ( ptr < end )
        set_pkt_type ( (uint16)(*ptr++) );
    return true;
}

bool HCI_WRITE_ENC_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_ENC_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set mode
    if ( ptr < end )
        set_mode ( (uint8)(*ptr++) );
    return true;
}

bool HCI_IO_CAPABILITY_REQUEST_NEG_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_IO_CAPABILITY_REQUEST_NEG_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set reason
    if ( ptr < end )
        set_reason ( (uint8)(*ptr++) );
    return true;
}

bool HCI_GET_LINK_QUALITY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_GET_LINK_QUALITY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_CHANGE_CONN_PKT_TYPE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_CHANGE_CONN_PKT_TYPE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set pkt_type
    if ( ptr < end )
        set_pkt_type ( (uint16)(*ptr++) );
    return true;
}

bool HCI_WRITE_VOICE_SETTING_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_VOICE_SETTING == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set voice_setting
    if ( ptr < end )
        set_voice_setting ( (uint16)(*ptr++) );
    return true;
}

bool HCI_READ_ENH_TX_POWER_LEVEL_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_ENH_TX_POWER_LEVEL == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set type
    if ( ptr < end )
        set_type ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ULP_SET_RANDOM_ADDRESS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_SET_RANDOM_ADDRESS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set random_address
    if ( ptr + 3 <= end )
    {
        set_random_address ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_READ_CLOCK_OFFSET_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_CLOCK_OFFSET == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_REMOTE_NAME_REQ_CANCEL_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_REMOTE_NAME_REQ_CANCEL == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_WRITE_STORED_LINK_KEY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_STORED_LINK_KEY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set number_keys
    if ( ptr < end )
        set_number_keys ( (uint8)(*ptr++) );
    // set link_key_bd_addr
    build_link_key_bd_addr(*this, parameters, &ptr, end);
    return true;
}

bool HCI_ULP_RECEIVER_TEST_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_RECEIVER_TEST == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set rx_channel
    if ( ptr < end )
        set_rx_channel ( (uint8)(*ptr++) );
    return true;
}

bool HCI_USER_PASSKEY_REQUEST_NEG_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_USER_PASSKEY_REQUEST_NEG_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_LINK_KEY_REQ_NEG_REPLY_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_LINK_KEY_REQ_NEG_REPLY == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_READ_LOCAL_EXT_FEATURES_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_READ_LOCAL_EXT_FEATURES == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set page_num
    if ( ptr < end )
        set_page_num ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ULP_REMOVE_DEVICE_FROM_WHITE_LIST_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_REMOVE_DEVICE_FROM_WHITE_LIST == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set address_type
    if ( ptr < end )
        set_address_type ( (uint8)(*ptr++) );
    // set address
    if ( ptr + 3 <= end )
    {
        set_address ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    return true;
}

bool HCI_ULP_READ_REMOTE_USED_FEATURES_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_READ_REMOTE_USED_FEATURES == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set connection_handle
    if ( ptr < end )
        set_connection_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_RESET_FIXED_ADDRESS_ATTEMPTS_COUNTER_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_RESET_FIXED_ADDRESS_ATTEMPTS_COUNTER == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set max_failures
    if ( ptr < end )
        set_max_failures ( (uint8)(*ptr++) );
    return true;
}

bool HCI_FLOW_SPEC_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_FLOW_SPEC == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 10 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set flags
    if ( ptr < end )
        set_flags ( (uint8)(*ptr++) );
    // set flow_direction
    if ( ptr < end )
        set_flow_direction ( (uint8)(*ptr++) );
    // set service_type
    if ( ptr < end )
        set_service_type ( (uint8)(*ptr++) );
    // set token_rate
    if ( ptr < end )
        set_token_rate ( (uint32)(*ptr++) );
    // set token_bucket_size
    if ( ptr < end )
        set_token_bucket_size ( (uint32)(*ptr++) );
    // set peak_bandwidth
    if ( ptr < end )
        set_peak_bandwidth ( (uint32)(*ptr++) );
    // set access_latency
    if ( ptr < end )
        set_access_latency ( (uint32)(*ptr++) );
    return true;
}

bool HCI_ULP_SET_EVENT_MASK_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_SET_EVENT_MASK == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set ulp_event_mask
    build_ulp_event_mask(*this, parameters, &ptr, end);
    return true;
}

bool HCI_SET_HCTOHOST_FLOW_CONTROL_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_SET_HCTOHOST_FLOW_CONTROL == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set enable
    if ( ptr < end )
        set_enable ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_SCAN_ENABLE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_SCAN_ENABLE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set scan_enable
    if ( ptr < end )
        set_scan_enable ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ULP_READ_CHANNEL_MAP_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_READ_CHANNEL_MAP == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set connection_handle
    if ( ptr < end )
        set_connection_handle ( (uint16)(*ptr++) );
    return true;
}

bool HCI_SNIFF_MODE_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_SNIFF_MODE == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 7 fields
    // set handle
    if ( ptr < end )
        set_handle ( (uint16)(*ptr++) );
    // set max_interval
    if ( ptr < end )
        set_max_interval ( (uint16)(*ptr++) );
    // set min_interval
    if ( ptr < end )
        set_min_interval ( (uint16)(*ptr++) );
    // set attempt
    if ( ptr < end )
        set_attempt ( (uint16)(*ptr++) );
    // set timeout
    if ( ptr < end )
        set_timeout ( (uint16)(*ptr++) );
    return true;
}

bool HCI_REJECT_CONNECTION_REQ_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_REJECT_CONNECTION_REQ == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set reason
    if ( ptr < end )
        set_reason ( (uint8)(*ptr++) );
    return true;
}

bool HCI_ULP_SET_ADVERTISING_PARAMETERS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_SET_ADVERTISING_PARAMETERS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 10 fields
    // set adv_interval_min
    if ( ptr < end )
        set_adv_interval_min ( (uint16)(*ptr++) );
    // set adv_interval_max
    if ( ptr < end )
        set_adv_interval_max ( (uint16)(*ptr++) );
    // set advertising_type
    if ( ptr < end )
        set_advertising_type ( (uint8)(*ptr++) );
    // set own_address_type
    if ( ptr < end )
        set_own_address_type ( (uint8)(*ptr++) );
    // set direct_address_type
    if ( ptr < end )
        set_direct_address_type ( (uint8)(*ptr++) );
    // set direct_address
    if ( ptr + 3 <= end )
    {
        set_direct_address ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set advertising_channel_map
    if ( ptr < end )
        set_advertising_channel_map ( (uint8)(*ptr++) );
    // set advertising_filter_policy
    if ( ptr < end )
        set_advertising_filter_policy ( (uint8)(*ptr++) );
    return true;
}

bool HCI_WRITE_ANON_ADDR_CHANGE_PARAMS_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_WRITE_ANON_ADDR_CHANGE_PARAMS == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set addr_update_time
    if ( ptr < end )
        set_addr_update_time ( (uint32)(*ptr++) );
    // set addr_inquiry_period
    if ( ptr < end )
        set_addr_inquiry_period ( (uint16)(*ptr++) );
    return true;
}

bool HCI_CREATE_CONNECTION_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_CREATE_CONNECTION == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 8 fields
    // set bd_addr
    if ( ptr + 3 <= end )
    {
        set_bd_addr ( BluetoothDeviceAddress( (uint16)ptr[2] , (uint8)ptr[1] , ptr[0]) );
        ptr += 3;
    }
    // set pkt_type
    if ( ptr < end )
        set_pkt_type ( (uint16)(*ptr++) );
    // set page_scan_rep_mode
    if ( ptr < end )
        set_page_scan_rep_mode ( (uint8)(*ptr++) );
    // set page_scan_mode
    if ( ptr < end )
        set_page_scan_mode ( (uint8)(*ptr++) );
    // set clock_offset
    if ( ptr < end )
        set_clock_offset ( (uint16)(*ptr++) );
    // set allow_role_switch
    if ( ptr < end )
        set_allow_role_switch ( (uint8)(*ptr++) );
    return true;
}

bool HCI_CHANGE_LOCAL_NAME_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_CHANGE_LOCAL_NAME == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 3 fields
    // set name_part
    build_name_part(*this, parameters, &ptr, end);
    return true;
}

bool HCI_ULP_SET_ADVERTISING_DATA_T_PDU::build( const uint32 * const parameters )
{
    assert ( HCI_ULP_SET_ADVERTISING_DATA == parameters[1] );
	const uint32 * ptr = &parameters[2];
	const uint32 * const end = parameters + parameters[0];
	// 4 fields
    // set advertising_data_len
    if ( ptr < end )
        set_advertising_data_len ( (uint8)(*ptr++) );
    // set advertising_data
    build_advertising_data(*this, parameters, &ptr, end);
    return true;
}


// end of part generated from cmd_build.tpl

