/////////////////////////WARNING - AUTOGENERATED FILE//////////////////////////
//
//  FILENAME:   gen_cmd_cmplt_pa.cpp
//
//  PURPOSE :   Body of giant switch for generating parameter arrays from
//              hci command complete pdus
//
//  Autogenerated from HCIPacker/autogen/templates/cmd_cmplt_switch.tpl by
//  devTools/bin/pdu/gencode.pl
//
///////////////////////////////////////////////////////////////////////////////

#include "hcipacker/hcicommandcompletepdu.h"
#include "hcipacker/legacy.h"
#include "app/bluestack/bluetooth.h"
#include "app/bluestack/hci.h"
#include <cassert>
#include "gen_hci_valid_commands.h"



static HCICommandCompletePDU *createHCICommandCompletePDU(HCICommandCompletePDU pdu)
{
    switch (pdu.get_op_code())
    {
    case HCI_ULP_READ_CHANNEL_MAP :
        return new HCI_ULP_READ_CHANNEL_MAP_RET_T_PDU(pdu);
    case HCI_ULP_LONG_TERM_KEY_REQUESTED_REPLY :
        return new HCI_ULP_LONG_TERM_KEY_REQUESTED_REPLY_RET_T_PDU(pdu);
    case HCI_READ_SCO_FLOW_CON_ENABLE :
        return new HCI_READ_SCO_FLOW_CON_ENABLE_RET_T_PDU(pdu);
    case HCI_READ_INQUIRY_MODE :
        return new HCI_READ_INQUIRY_MODE_RET_T_PDU(pdu);
    case HCI_GET_LINK_QUALITY :
        return new HCI_GET_LINK_QUALITY_RET_T_PDU(pdu);
    case HCI_READ_HOLD_MODE_ACTIVITY :
        return new HCI_READ_HOLD_MODE_ACTIVITY_RET_T_PDU(pdu);
    case HCI_ULP_READ_ADVERTISING_CHANNEL_TX_POWER :
        return new HCI_ULP_READ_ADVERTISING_CHANNEL_TX_POWER_RET_T_PDU(pdu);
    case HCI_READ_ALIAS_AUTH_ENABLE :
        return new HCI_READ_ALIAS_AUTH_ENABLE_RET_T_PDU(pdu);
    case HCI_READ_INQUIRYSCAN_ACTIVITY :
        return new HCI_READ_INQUIRYSCAN_ACTIVITY_RET_T_PDU(pdu);
    case HCI_RESET_FAILED_CONTACT_COUNT :
        return new HCI_RESET_FAILED_CONTACT_COUNT_RET_T_PDU(pdu);
    case HCI_USER_PASSKEY_REQUEST_REPLY :
        return new HCI_USER_PASSKEY_REQUEST_REPLY_RET_T_PDU(pdu);
    case HCI_LINK_KEY_REQ_REPLY :
        return new HCI_LINK_KEY_REQ_REPLY_RET_T_PDU(pdu);
    case HCI_READ_CLOCK :
        return new HCI_READ_CLOCK_RET_T_PDU(pdu);
    case HCI_READ_LMP_HANDLE :
        return new HCI_READ_LMP_HANDLE_RET_T_PDU(pdu);
    case HCI_READ_PAGE_SCAN_TYPE :
        return new HCI_READ_PAGE_SCAN_TYPE_RET_T_PDU(pdu);
    case HCI_ULP_READ_LOCAL_SUPPORTED_FEATURES :
        return new HCI_ULP_READ_LOCAL_SUPPORTED_FEATURES_RET_T_PDU(pdu);
    case HCI_LINK_KEY_REQ_NEG_REPLY :
        return new HCI_LINK_KEY_REQ_NEG_REPLY_RET_T_PDU(pdu);
    case HCI_PIN_CODE_REQ_NEG_REPLY :
        return new HCI_PIN_CODE_REQ_NEG_REPLY_RET_T_PDU(pdu);
    case HCI_READ_PAGESCAN_PERIOD_MODE :
        return new HCI_READ_PAGESCAN_PERIOD_MODE_RET_T_PDU(pdu);
    case HCI_ROLE_DISCOVERY :
        return new HCI_ROLE_DISCOVERY_RET_T_PDU(pdu);
    case HCI_READ_CONN_ACCEPT_TIMEOUT :
        return new HCI_READ_CONN_ACCEPT_TIMEOUT_RET_T_PDU(pdu);
    case HCI_REMOTE_NAME_REQ_CANCEL :
        return new HCI_REMOTE_NAME_REQ_CANCEL_RET_T_PDU(pdu);
    case HCI_READ_ENCRYPTION_KEY_SIZE :
        return new HCI_READ_ENCRYPTION_KEY_SIZE_RET_T_PDU(pdu);
    case HCI_DELETE_STORED_LINK_KEY :
        return new HCI_DELETE_STORED_LINK_KEY_RET_T_PDU(pdu);
    case HCI_ULP_TEST_END :
        return new HCI_ULP_TEST_END_RET_T_PDU(pdu);
    case HCI_ULP_READ_WHITE_LIST_SIZE :
        return new HCI_ULP_READ_WHITE_LIST_SIZE_RET_T_PDU(pdu);
    case HCI_ULP_READ_SUPPORTED_STATES :
        return new HCI_ULP_READ_SUPPORTED_STATES_RET_T_PDU(pdu);
    case HCI_READ_ENH_TX_POWER_LEVEL :
        return new HCI_READ_ENH_TX_POWER_LEVEL_RET_T_PDU(pdu);
    case HCI_READ_LOOPBACK_MODE :
        return new HCI_READ_LOOPBACK_MODE_RET_T_PDU(pdu);
    case HCI_READ_BUFFER_SIZE :
        return new HCI_READ_BUFFER_SIZE_RET_T_PDU(pdu);
    case HCI_READ_LE_HOST_SUPPORT :
        return new HCI_READ_LE_HOST_SUPPORT_RET_T_PDU(pdu);
    case HCI_WRITE_AUTO_FLUSH_TIMEOUT :
        return new HCI_WRITE_AUTO_FLUSH_TIMEOUT_RET_T_PDU(pdu);
    case HCI_IO_CAPABILITY_RESPONSE :
        return new HCI_IO_CAPABILITY_RESPONSE_RET_T_PDU(pdu);
    case HCI_PRIVATE_PAIRING_REQ_NEG_REPLY :
        return new HCI_PRIVATE_PAIRING_REQ_NEG_REPLY_RET_T_PDU(pdu);
    case HCI_ALIAS_ADDRESS_REQ_REPLY :
        return new HCI_ALIAS_ADDRESS_REQ_REPLY_RET_T_PDU(pdu);
    case HCI_READ_AUTO_FLUSH_TIMEOUT :
        return new HCI_READ_AUTO_FLUSH_TIMEOUT_RET_T_PDU(pdu);
    case HCI_READ_LOCAL_NAME :
        return new HCI_READ_LOCAL_NAME_RET_T_PDU(pdu);
    case HCI_ULP_RAND :
        return new HCI_ULP_RAND_RET_T_PDU(pdu);
    case HCI_READ_EXTENDED_INQUIRY_RESPONSE_DATA :
        return new HCI_READ_EXTENDED_INQUIRY_RESPONSE_DATA_RET_T_PDU(pdu);
    case HCI_USER_CONFIRMATION_REQUEST_NEG_REPLY :
        return new HCI_USER_CONFIRMATION_REQUEST_NEG_REPLY_RET_T_PDU(pdu);
    case HCI_ULP_ENCRYPT :
        return new HCI_ULP_ENCRYPT_RET_T_PDU(pdu);
    case HCI_READ_SIMPLE_PAIRING_MODE :
        return new HCI_READ_SIMPLE_PAIRING_MODE_RET_T_PDU(pdu);
    case HCI_READ_BD_ADDR :
        return new HCI_READ_BD_ADDR_RET_T_PDU(pdu);
    case HCI_READ_LOCAL_VER_INFO :
        return new HCI_READ_LOCAL_VER_INFO_RET_T_PDU(pdu);
    case HCI_READ_CURRENT_IAC_LAP :
        return new HCI_READ_CURRENT_IAC_LAP_RET_T_PDU(pdu);
    case HCI_READ_LOCAL_EXT_FEATURES :
        return new HCI_READ_LOCAL_EXT_FEATURES_RET_T_PDU(pdu);
    case HCI_READ_NUM_BCAST_RETXS :
        return new HCI_READ_NUM_BCAST_RETXS_RET_T_PDU(pdu);
    case HCI_READ_INQUIRY_RESPONSE_TX_POWER_LEVEL :
        return new HCI_READ_INQUIRY_RESPONSE_TX_POWER_LEVEL_RET_T_PDU(pdu);
    case HCI_READ_NUM_SUPPORTED_IAC :
        return new HCI_READ_NUM_SUPPORTED_IAC_RET_T_PDU(pdu);
    case HCI_READ_COUNTRY_CODE :
        return new HCI_READ_COUNTRY_CODE_RET_T_PDU(pdu);
    case HCI_READ_FAILED_CONTACT_COUNT :
        return new HCI_READ_FAILED_CONTACT_COUNT_RET_T_PDU(pdu);
    case HCI_READ_PIN_TYPE :
        return new HCI_READ_PIN_TYPE_RET_T_PDU(pdu);
    case HCI_READ_LOCAL_OOB_DATA :
        return new HCI_READ_LOCAL_OOB_DATA_RET_T_PDU(pdu);
    case HCI_SNIFF_SUB_RATE :
        return new HCI_SNIFF_SUB_RATE_RET_T_PDU(pdu);
    case HCI_READ_AUTH_ENABLE :
        return new HCI_READ_AUTH_ENABLE_RET_T_PDU(pdu);
    case HCI_READ_LINK_POLICY_SETTINGS :
        return new HCI_READ_LINK_POLICY_SETTINGS_RET_T_PDU(pdu);
    case HCI_READ_INQUIRY_SCAN_TYPE :
        return new HCI_READ_INQUIRY_SCAN_TYPE_RET_T_PDU(pdu);
    case HCI_SEND_KEYPRESS_NOTIFICATION :
        return new HCI_SEND_KEYPRESS_NOTIFICATION_RET_T_PDU(pdu);
    case HCI_REMOTE_OOB_DATA_REQUEST_NEG_REPLY :
        return new HCI_REMOTE_OOB_DATA_REQUEST_NEG_REPLY_RET_T_PDU(pdu);
    case HCI_READ_PAGE_TIMEOUT :
        return new HCI_READ_PAGE_TIMEOUT_RET_T_PDU(pdu);
    case HCI_IO_CAPABILITY_REQUEST_NEG_REPLY :
        return new HCI_IO_CAPABILITY_REQUEST_NEG_REPLY_RET_T_PDU(pdu);
    case HCI_ULP_READ_BUFFER_SIZE :
        return new HCI_ULP_READ_BUFFER_SIZE_RET_T_PDU(pdu);
    case HCI_READ_VOICE_SETTING :
        return new HCI_READ_VOICE_SETTING_RET_T_PDU(pdu);
    case HCI_ULP_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY :
        return new HCI_ULP_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY_RET_T_PDU(pdu);
    case HCI_READ_SCAN_ENABLE :
        return new HCI_READ_SCAN_ENABLE_RET_T_PDU(pdu);
    case HCI_READ_TX_POWER_LEVEL :
        return new HCI_READ_TX_POWER_LEVEL_RET_T_PDU(pdu);
    case HCI_ALIAS_ADDRESS_REQ_NEG_REPLY :
        return new HCI_ALIAS_ADDRESS_REQ_NEG_REPLY_RET_T_PDU(pdu);
    case HCI_READ_LINK_SUPERV_TIMEOUT :
        return new HCI_READ_LINK_SUPERV_TIMEOUT_RET_T_PDU(pdu);
    case HCI_PRIVATE_PAIRING_REQ_REPLY :
        return new HCI_PRIVATE_PAIRING_REQ_REPLY_RET_T_PDU(pdu);
    case HCI_PIN_CODE_REQ_REPLY :
        return new HCI_PIN_CODE_REQ_REPLY_RET_T_PDU(pdu);
    case HCI_USER_CONFIRMATION_REQUEST_REPLY :
        return new HCI_USER_CONFIRMATION_REQUEST_REPLY_RET_T_PDU(pdu);
    case HCI_READ_AFH_CHANNEL_MAP :
        return new HCI_READ_AFH_CHANNEL_MAP_RET_T_PDU(pdu);
    case HCI_READ_AFH_CHANNEL_CLASS_M :
        return new HCI_READ_AFH_CHANNEL_CLASS_M_RET_T_PDU(pdu);
    case HCI_GENERATED_ALIAS :
        return new HCI_GENERATED_ALIAS_RET_T_PDU(pdu);
    case HCI_READ_PAGESCAN_ACTIVITY :
        return new HCI_READ_PAGESCAN_ACTIVITY_RET_T_PDU(pdu);
    case HCI_READ_DEFAULT_LINK_POLICY_SETTINGS :
        return new HCI_READ_DEFAULT_LINK_POLICY_SETTINGS_RET_T_PDU(pdu);
    case HCI_READ_LOCAL_SUPP_COMMANDS :
        return new HCI_READ_LOCAL_SUPP_COMMANDS_RET_T_PDU(pdu);
    case HCI_READ_PAGESCAN_MODE :
        return new HCI_READ_PAGESCAN_MODE_RET_T_PDU(pdu);
    case HCI_USER_PASSKEY_REQUEST_NEG_REPLY :
        return new HCI_USER_PASSKEY_REQUEST_NEG_REPLY_RET_T_PDU(pdu);
    case HCI_CREATE_CONNECTION_CANCEL :
        return new HCI_CREATE_CONNECTION_CANCEL_RET_T_PDU(pdu);
    case HCI_READ_ENC_MODE :
        return new HCI_READ_ENC_MODE_RET_T_PDU(pdu);
    case HCI_REMOTE_OOB_DATA_REQUEST_REPLY :
        return new HCI_REMOTE_OOB_DATA_REQUEST_REPLY_RET_T_PDU(pdu);
    case HCI_WRITE_LINK_SUPERV_TIMEOUT :
        return new HCI_WRITE_LINK_SUPERV_TIMEOUT_RET_T_PDU(pdu);
    case HCI_READ_ANON_ADDR_CHANGE_PARAMS :
        return new HCI_READ_ANON_ADDR_CHANGE_PARAMS_RET_T_PDU(pdu);
    case HCI_FLUSH :
        return new HCI_FLUSH_RET_T_PDU(pdu);
    case HCI_READ_LOCAL_SUPP_FEATURES :
        return new HCI_READ_LOCAL_SUPP_FEATURES_RET_T_PDU(pdu);
    case HCI_WRITE_STORED_LINK_KEY :
        return new HCI_WRITE_STORED_LINK_KEY_RET_T_PDU(pdu);
    case HCI_READ_RSSI :
        return new HCI_READ_RSSI_RET_T_PDU(pdu);
    case HCI_READ_STORED_LINK_KEY :
        return new HCI_READ_STORED_LINK_KEY_RET_T_PDU(pdu);
    case HCI_WRITE_LINK_POLICY_SETTINGS :
        return new HCI_WRITE_LINK_POLICY_SETTINGS_RET_T_PDU(pdu);
    case HCI_READ_ANON_MODE :
        return new HCI_READ_ANON_MODE_RET_T_PDU(pdu);
    case HCI_READ_CLASS_OF_DEVICE :
        return new HCI_READ_CLASS_OF_DEVICE_RET_T_PDU(pdu);
    default:
        if (isValidHCICommand(pdu.get_op_code()))
        {
    		return new HCICommandCompletePDU(pdu);
        }
        else
        {
            return 0;
        }
    }
} // end createHCIComandPDU

uint32 HCIPDUFactory::decomposeCommandCompletePDU(const PDU& hci, uint32 * toFill, BadPDUReason& why_failed)
{
    assert(PDU::hciCommand == hci.channel());

    uint32 length(0);
    bool ok(false);

    //  start after the length field, event code, status and opcode.
    HCICommandCompletePDU *pdu = createHCICommandCompletePDU(hci);
    if (pdu)
    {    
        ok = pdu->decompose(toFill, why_failed, length);
        delete pdu;
    }
    else
    {
        why_failed = BP_NO_SUCH_COMMAND;
    }
    
    return ok ? length : 0;
}

// end of part generated by cmd_cmplt_switch.tpl

// start of part generated from cmd_cmplt_build.tpl 

#include <cassert>

bool HCI_ULP_READ_CHANNEL_MAP_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get connection_handle
    if ( toFill )
        toFill[length] = this->get_connection_handle();
    length++;
    //  get ulp_channel_map
    //  ULP channel map
    if ( toFill )
    {
        ULPChannelMap m = this->get_ulp_channel_map();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( (uint8*)m.get_ptr() , 5 , toFill , &ptr );
    }
    length += 5;
    return ok;
}

bool HCI_ULP_LONG_TERM_KEY_REQUESTED_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get connection_handle
    if ( toFill )
        toFill[length] = this->get_connection_handle();
    length++;
    return ok;
}

bool HCI_READ_SCO_FLOW_CON_ENABLE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get sco_flow_control_enable
    if ( toFill )
        toFill[length] = this->get_sco_flow_control_enable();
    length++;
    return ok;
}

bool HCI_READ_INQUIRY_MODE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get mode
    if ( toFill )
        toFill[length] = this->get_mode();
    length++;
    return ok;
}

bool HCI_GET_LINK_QUALITY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get link_quality
    if ( toFill )
        toFill[length] = this->get_link_quality();
    length++;
    return ok;
}

bool HCI_READ_HOLD_MODE_ACTIVITY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get activity
    if ( toFill )
        toFill[length] = this->get_activity();
    length++;
    return ok;
}

bool HCI_ULP_READ_ADVERTISING_CHANNEL_TX_POWER_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get tx_power
    if ( toFill )
        toFill[length] = this->get_tx_power();
    length++;
    return ok;
}

bool HCI_READ_ALIAS_AUTH_ENABLE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get enabled
    if ( toFill )
        toFill[length] = this->get_enabled();
    length++;
    return ok;
}

bool HCI_READ_INQUIRYSCAN_ACTIVITY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get inqscan_interval
    if ( toFill )
        toFill[length] = this->get_inqscan_interval();
    length++;
    //  get inqscan_window
    if ( toFill )
        toFill[length] = this->get_inqscan_window();
    length++;
    return ok;
}

bool HCI_RESET_FAILED_CONTACT_COUNT_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    return ok;
}

bool HCI_USER_PASSKEY_REQUEST_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_LINK_KEY_REQ_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_READ_CLOCK_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get clock
    if ( toFill )
        toFill[length] = this->get_clock();
    length++;
    //  get accuracy
    if ( toFill )
        toFill[length] = this->get_accuracy();
    length++;
    return ok;
}

bool HCI_READ_LMP_HANDLE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get lmp_handle
    if ( toFill )
        toFill[length] = this->get_lmp_handle();
    length++;
    //  get reserved
    if ( toFill )
        toFill[length] = this->get_reserved();
    length++;
    return ok;
}

bool HCI_READ_PAGE_SCAN_TYPE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get mode
    if ( toFill )
        toFill[length] = this->get_mode();
    length++;
    return ok;
}

bool HCI_ULP_READ_LOCAL_SUPPORTED_FEATURES_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get feature_set
    //  ulp supported features
    if ( toFill )
    {
        ULPSupportedFeatures l = this->get_feature_set();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( l.get_ptr() , 8 , toFill , &ptr );
    }
    length += 8;
    return ok;
}

bool HCI_LINK_KEY_REQ_NEG_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_PIN_CODE_REQ_NEG_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_READ_PAGESCAN_PERIOD_MODE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get mode
    if ( toFill )
        toFill[length] = this->get_mode();
    length++;
    return ok;
}

bool HCI_ROLE_DISCOVERY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get current_role
    if ( toFill )
        toFill[length] = this->get_current_role();
    length++;
    return ok;
}

bool HCI_READ_CONN_ACCEPT_TIMEOUT_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get conn_accept_timeout
    if ( toFill )
        toFill[length] = this->get_conn_accept_timeout();
    length++;
    return ok;
}

bool HCI_REMOTE_NAME_REQ_CANCEL_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_READ_ENCRYPTION_KEY_SIZE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get key_size
    if ( toFill )
        toFill[length] = this->get_key_size();
    length++;
    return ok;
}

bool HCI_DELETE_STORED_LINK_KEY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get num_keys_deleted
    if ( toFill )
        toFill[length] = this->get_num_keys_deleted();
    length++;
    return ok;
}

bool HCI_ULP_TEST_END_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get number_of_packets
    if ( toFill )
        toFill[length] = this->get_number_of_packets();
    length++;
    return ok;
}

bool HCI_ULP_READ_WHITE_LIST_SIZE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get white_list_size
    if ( toFill )
        toFill[length] = this->get_white_list_size();
    length++;
    return ok;
}

bool HCI_ULP_READ_SUPPORTED_STATES_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get supported_states
    //  ULP supported states
    if ( toFill )
    {
        ULPSupportedStates m = this->get_supported_states();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( m.get_ptr() , 8 , toFill , &ptr );
    }
    length += 8;
    return ok;
}

bool HCI_READ_ENH_TX_POWER_LEVEL_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get pwr_level_GFSK
    if ( toFill )
        toFill[length] = this->get_pwr_level_GFSK();
    length++;
    //  get pwr_level_DQPSK
    if ( toFill )
        toFill[length] = this->get_pwr_level_DQPSK();
    length++;
    //  get pwr_level_8DPSK
    if ( toFill )
        toFill[length] = this->get_pwr_level_8DPSK();
    length++;
    return ok;
}

bool HCI_READ_LOOPBACK_MODE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get mode
    if ( toFill )
        toFill[length] = this->get_mode();
    length++;
    return ok;
}

bool HCI_READ_BUFFER_SIZE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get acl_data_pkt_length
    if ( toFill )
        toFill[length] = this->get_acl_data_pkt_length();
    length++;
    //  get sco_data_pkt_length
    if ( toFill )
        toFill[length] = this->get_sco_data_pkt_length();
    length++;
    //  get total_acl_data_pkts
    if ( toFill )
        toFill[length] = this->get_total_acl_data_pkts();
    length++;
    //  get total_sco_data_pkts
    if ( toFill )
        toFill[length] = this->get_total_sco_data_pkts();
    length++;
    return ok;
}

bool HCI_READ_LE_HOST_SUPPORT_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get le_supported_host
    if ( toFill )
        toFill[length] = this->get_le_supported_host();
    length++;
    //  get simultaneous_le_host
    if ( toFill )
        toFill[length] = this->get_simultaneous_le_host();
    length++;
    return ok;
}

bool HCI_WRITE_AUTO_FLUSH_TIMEOUT_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    return ok;
}

bool HCI_IO_CAPABILITY_RESPONSE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_PRIVATE_PAIRING_REQ_NEG_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    return ok;
}

bool HCI_ALIAS_ADDRESS_REQ_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_READ_AUTO_FLUSH_TIMEOUT_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get timeout
    if ( toFill )
        toFill[length] = this->get_timeout();
    length++;
    return ok;
}

bool HCI_READ_LOCAL_NAME_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get name_part
    //  Bluetooth device name
    if ( toFill )
    {
        BluetoothName n = this->get_name_part();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( (uint8*)n.get_str() , 248 , toFill , &ptr );
    }
    length += 248;
    return ok;
}

bool HCI_ULP_RAND_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get random_number
    //  ulp random number
    if ( toFill )
    {
        DATA_uint8_len_32_ret l = this->get_random_number();
        uint32 * ptr = toFill + length ;
        ok = HCIPDUFactory::encodeBytes( l.get_ptr() , 17 , toFill , &ptr );
    }
    length += 17;
    return ok;
}

bool HCI_READ_EXTENDED_INQUIRY_RESPONSE_DATA_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get fec_required
    if ( toFill )
        toFill[length] = this->get_fec_required();
    length++;
    //  get eir_data_part
    //  Extended Inquiry Response data
    if ( toFill )
    {
        EIRData d = this->get_eir_data_part();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( (uint8*)d.get_data() , 240 , toFill , &ptr );
    }
    length += 240;
    return ok;
}

bool HCI_USER_CONFIRMATION_REQUEST_NEG_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_ULP_ENCRYPT_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get encrypted_data
    //  DATA_uint8_len_16_ret
    if ( toFill )
    {
        DATA_uint8_len_16_ret data_obj = this->get_encrypted_data();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( (uint8*)data_obj.get_ptr() , 16 , toFill , &ptr );
    }
    length += 16;
    return ok;
}

bool HCI_READ_SIMPLE_PAIRING_MODE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get simple_pairing_mode
    if ( toFill )
        toFill[length] = this->get_simple_pairing_mode();
    length++;
    return ok;
}

bool HCI_READ_BD_ADDR_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_READ_LOCAL_VER_INFO_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get hci_version
    if ( toFill )
        toFill[length] = this->get_hci_version();
    length++;
    //  get hci_revision
    if ( toFill )
        toFill[length] = this->get_hci_revision();
    length++;
    //  get lmp_version
    if ( toFill )
        toFill[length] = this->get_lmp_version();
    length++;
    //  get manuf_name
    if ( toFill )
        toFill[length] = this->get_manuf_name();
    length++;
    //  get lmp_subversion
    if ( toFill )
        toFill[length] = this->get_lmp_subversion();
    length++;
    return ok;
}

bool HCI_READ_CURRENT_IAC_LAP_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get num_current_iac
    if ( toFill )
        toFill[length] = this->get_num_current_iac();
    length++;
    //  get iac_lap
    //  list of iacs
    uint8 count = this->get_num_current_iac();
    if ( toFill )
        for ( uint8 i = 0 ; i < count ; i++ )
            toFill[ length + i ] = this->get_iac_lap(i);
    length += count;
    return ok;
}

bool HCI_READ_LOCAL_EXT_FEATURES_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get page_num
    if ( toFill )
        toFill[length] = this->get_page_num();
    length++;
    //  get max_page_num
    if ( toFill )
        toFill[length] = this->get_max_page_num();
    length++;
    //  get lmp_ext_features
    //  lmp supported features
    if ( toFill )
    {
        LMPSupportedFeatures l = this->get_lmp_ext_features();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( l.get_data() , 8 , toFill , &ptr );
    }
    length += 8;
    return ok;
}

bool HCI_READ_NUM_BCAST_RETXS_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get num
    if ( toFill )
        toFill[length] = this->get_num();
    length++;
    return ok;
}

bool HCI_READ_INQUIRY_RESPONSE_TX_POWER_LEVEL_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get tx_power
    if ( toFill )
        toFill[length] = this->get_tx_power();
    length++;
    return ok;
}

bool HCI_READ_NUM_SUPPORTED_IAC_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get num
    if ( toFill )
        toFill[length] = this->get_num();
    length++;
    return ok;
}

bool HCI_READ_COUNTRY_CODE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get country_code
    if ( toFill )
        toFill[length] = this->get_country_code();
    length++;
    return ok;
}

bool HCI_READ_FAILED_CONTACT_COUNT_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get failed_contact_count
    if ( toFill )
        toFill[length] = this->get_failed_contact_count();
    length++;
    return ok;
}

bool HCI_READ_PIN_TYPE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get pin_type
    if ( toFill )
        toFill[length] = this->get_pin_type();
    length++;
    return ok;
}

bool HCI_READ_LOCAL_OOB_DATA_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get c
    //  SPhashC
	if ( toFill )
    {
        SPhashC c = this->get_c();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( (uint8*)c.get_data() , 16 , toFill , &ptr );
    }
    length += 16;
    //  get r
    //  SPrandomizerR
	if ( toFill )
    {
        SPrandomizerR r = this->get_r();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( (uint8*)r.get_data() , 16 , toFill , &ptr );
    }
    length += 16;
    return ok;
}

bool HCI_SNIFF_SUB_RATE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    return ok;
}

bool HCI_READ_AUTH_ENABLE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get auth_enable
    if ( toFill )
        toFill[length] = this->get_auth_enable();
    length++;
    return ok;
}

bool HCI_READ_LINK_POLICY_SETTINGS_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get link_policy_settings
    if ( toFill )
        toFill[length] = this->get_link_policy_settings();
    length++;
    return ok;
}

bool HCI_READ_INQUIRY_SCAN_TYPE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get mode
    if ( toFill )
        toFill[length] = this->get_mode();
    length++;
    return ok;
}

bool HCI_SEND_KEYPRESS_NOTIFICATION_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_REMOTE_OOB_DATA_REQUEST_NEG_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_READ_PAGE_TIMEOUT_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get page_timeout
    if ( toFill )
        toFill[length] = this->get_page_timeout();
    length++;
    return ok;
}

bool HCI_IO_CAPABILITY_REQUEST_NEG_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_ULP_READ_BUFFER_SIZE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get data_packet_length
    if ( toFill )
        toFill[length] = this->get_data_packet_length();
    length++;
    //  get num_data_packets
    if ( toFill )
        toFill[length] = this->get_num_data_packets();
    length++;
    return ok;
}

bool HCI_READ_VOICE_SETTING_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get voice_setting
    if ( toFill )
        toFill[length] = this->get_voice_setting();
    length++;
    return ok;
}

bool HCI_ULP_LONG_TERM_KEY_REQUESTED_NEGATIVE_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get connection_handle
    if ( toFill )
        toFill[length] = this->get_connection_handle();
    length++;
    return ok;
}

bool HCI_READ_SCAN_ENABLE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get scan_enable
    if ( toFill )
        toFill[length] = this->get_scan_enable();
    length++;
    return ok;
}

bool HCI_READ_TX_POWER_LEVEL_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get pwr_level
    if ( toFill )
        toFill[length] = this->get_pwr_level();
    length++;
    return ok;
}

bool HCI_ALIAS_ADDRESS_REQ_NEG_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_READ_LINK_SUPERV_TIMEOUT_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get timeout
    if ( toFill )
        toFill[length] = this->get_timeout();
    length++;
    return ok;
}

bool HCI_PRIVATE_PAIRING_REQ_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    return ok;
}

bool HCI_PIN_CODE_REQ_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_USER_CONFIRMATION_REQUEST_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_READ_AFH_CHANNEL_MAP_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get mode
    if ( toFill )
        toFill[length] = this->get_mode();
    length++;
    //  get map
    //  AFH map
    if ( toFill )
    {
        AFHmap m = this->get_map();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( (uint8*)m.get_ptr() , 10 , toFill , &ptr );
    }
    length += 10;
    return ok;
}

bool HCI_READ_AFH_CHANNEL_CLASS_M_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get class_mode
    if ( toFill )
        toFill[length] = this->get_class_mode();
    length++;
    return ok;
}

bool HCI_GENERATED_ALIAS_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    return ok;
}

bool HCI_READ_PAGESCAN_ACTIVITY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get pagescan_interval
    if ( toFill )
        toFill[length] = this->get_pagescan_interval();
    length++;
    //  get pagescan_window
    if ( toFill )
        toFill[length] = this->get_pagescan_window();
    length++;
    return ok;
}

bool HCI_READ_DEFAULT_LINK_POLICY_SETTINGS_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get default_lps
    if ( toFill )
        toFill[length] = this->get_default_lps();
    length++;
    return ok;
}

bool HCI_READ_LOCAL_SUPP_COMMANDS_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get supp_commands
    //  supported commands
    if ( toFill )
    {
        SupportedCommands sc = this->get_supp_commands();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( sc.get_data() , 64 , toFill , &ptr );
    }
    length += 64;
    return ok;
}

bool HCI_READ_PAGESCAN_MODE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get mode
    if ( toFill )
        toFill[length] = this->get_mode();
    length++;
    return ok;
}

bool HCI_USER_PASSKEY_REQUEST_NEG_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_CREATE_CONNECTION_CANCEL_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_READ_ENC_MODE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get mode
    if ( toFill )
        toFill[length] = this->get_mode();
    length++;
    return ok;
}

bool HCI_REMOTE_OOB_DATA_REQUEST_REPLY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get bd_addr
    if ( toFill )
    {
        BluetoothDeviceAddress bda = this->get_bd_addr();
        toFill[length] = bda.get_lap();
        toFill[length+1] = bda.get_uap();
        toFill[length+2] = bda.get_nap();
    }
    length += 3;
    return ok;
}

bool HCI_WRITE_LINK_SUPERV_TIMEOUT_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    return ok;
}

bool HCI_READ_ANON_ADDR_CHANGE_PARAMS_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get addr_update_time
    if ( toFill )
        toFill[length] = this->get_addr_update_time();
    length++;
    //  get addr_inquiry_period
    if ( toFill )
        toFill[length] = this->get_addr_inquiry_period();
    length++;
    return ok;
}

bool HCI_FLUSH_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    return ok;
}

bool HCI_READ_LOCAL_SUPP_FEATURES_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get lmp_supp_features
    //  lmp supported features
    if ( toFill )
    {
        LMPSupportedFeatures l = this->get_lmp_supp_features();
        uint32 * ptr = toFill + length;
        ok = HCIPDUFactory::encodeBytes( l.get_data() , 8 , toFill , &ptr );
    }
    length += 8;
    return ok;
}

bool HCI_WRITE_STORED_LINK_KEY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get num_keys_written
    if ( toFill )
        toFill[length] = this->get_num_keys_written();
    length++;
    return ok;
}

bool HCI_READ_RSSI_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    //  get rssi
    if ( toFill )
        toFill[length] = this->get_rssi();
    length++;
    return ok;
}

bool HCI_READ_STORED_LINK_KEY_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get max_num_keys
    if ( toFill )
        toFill[length] = this->get_max_num_keys();
    length++;
    //  get num_keys_read
    if ( toFill )
        toFill[length] = this->get_num_keys_read();
    length++;
    return ok;
}

bool HCI_WRITE_LINK_POLICY_SETTINGS_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get handle
    if ( toFill )
        toFill[length] = this->get_handle();
    length++;
    return ok;
}

bool HCI_READ_ANON_MODE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get mode
    if ( toFill )
        toFill[length] = this->get_mode();
    length++;
    return ok;
}

bool HCI_READ_CLASS_OF_DEVICE_RET_T_PDU::decompose(uint32 * toFill, BadPDUReason& why_failed, uint32 &length) const
{
    bool ok(true);
    if (!(this->size_ok() && this->size_expected()))
    {
        why_failed = BP_HCI_WRONG_SIZE;
        return false;
    }
    
    HCICommandCompletePDU::decompose(toFill, why_failed, length);
    
    //  get dev_class
    if ( toFill )
        toFill[length] = this->get_dev_class();
    length++;
    return ok;
}


// end of part generated by cmd_cmplt_build.tpl

