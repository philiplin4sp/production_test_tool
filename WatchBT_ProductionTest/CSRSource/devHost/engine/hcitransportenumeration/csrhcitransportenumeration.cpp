// Enumerate available transports

#include "windows.h"
#include "csrhcitransportenumeration.h"
#include "question/question.h"
#include "question/answer.h"
#include "../hcitransport/phys/uart.h"
#ifndef _WIN32_WCE
#include "../hcitransport/phys/usb.h"
#endif

#include <string>
#include <map>
#include "common/algorithm.h"

#include "unicode/ichar.h"
static std::string prependSystemName (const std::string &s)
{
    return "\\\\.\\" + s;
}

//  Root name
static char * protocolName = "Transport type";

//  Options under protocol
static const MenuPair bcspName("bcsp","BCSP");
static const MenuPair h4Name("h4","H4");
static const MenuPair h4dsName("h4ds","H4DS");
static const MenuPair usbName("h2","USB");
static const MenuPair h5Name("h5","H5");

//  fields under Uart transports, options are auto generated.
static char * portName = "Serial port";
static std::string comPortName(int port)
{
    char buff[32];
    sprintf(buff, "com%d", port+1);
    return buff;
}

//  Pipe names
static std::string pipeName(int port)
{
    char buff[32];
    sprintf(buff, "pipe\\csr%d", port);
    return buff;
}

//  fields under H2 transport, options are autogenerated.
static char * endpointName = "USB Device";
static std::string csrEndpointName(int number)
{
    char buff[32];
    sprintf(buff, "csr%d", number);
    return buff;
}
static std::string WidcommEndpointName(int number)
{
    char buff[32];
    if ( number < 10 )
        sprintf(buff,"btwusb-%d",number);
    else
        buff[0] = 0;
    return buff;
}

//  fields under serial ports, and the options.
static char * baudName = "Baud rate";
static char * rates[] = {"115200","230400","460800","921600","1382400","57600","38400","19200","9600","4800","2400","1200","600","300","120"};

static Question enumerateSpeeds(const std::string &port)
{
  PreformedQuestion result(baudName);
#ifndef _WIN32_WCE
  UARTConfiguration lBaseConfig ( prependSystemName(port).c_str() , 0 , UARTConfiguration::none , 0 , false , 0 );
#else
  wchar_t* wName = new wchar_t[port.size()+1];
  MultiByteToWideChar(CP_ACP,0,port.c_str(),-1,wName,port.size()+1);
  UARTConfiguration lBaseConfig ( wName , 0 , UARTConfiguration::none , 0 , false , 0 );
#endif

  if ( lBaseConfig.testOpen() )
  {
    for(int i = 0; i < sizeof(rates) / sizeof(rates[0]); ++i)
    {
#ifndef _WIN32_WCE
		UARTConfiguration lConf( prependSystemName(port).c_str() , atoi(rates[i]) , UARTConfiguration::none , 0 , false , 0 );
		UARTPtr lPort( lConf.make() );
#else
		UARTConfiguration lConf( wName , atoi(rates[i]) , UARTConfiguration::none , 0 , false , 0 );
		UARTAbstraction * lPort = lConf.make();
#endif
		if( lPort->open() )
	        result.add_answer(rates[i],rates[i]);
#ifdef _WIN32_WCE
		delete lPort;
#endif
    }
  }
#ifdef _WIN32_WCE
	delete [] wName;
#endif
  return result;
}

static Question enumeratePorts()
{
  PreformedQuestion ports(portName);
  for(int com = 0; com < 128; ++com)
  {
    std::string port = comPortName(com);

    Question speeds = enumerateSpeeds(port);
    if( speeds.replies_begin() != speeds.replies_end() )
      ports.add_answer(port.c_str(),port.c_str(),speeds);
  }
  for(int pipe = 0 ; pipe < 128 ; ++pipe)
  {
    std::string port = pipeName ( pipe );
    if ( UARTConfiguration ( prependSystemName(port).c_str() ).testOpen() )
      ports.add_answer(port.c_str(),port.c_str());
  }
  return ports;
}
#ifndef _WIN32_WCE
static Question enumerateUSB()
{
    PreformedQuestion result(endpointName);
    int dev;
    for ( dev = 0 ; dev < 128 ; ++dev )
    {
        std::string device = csrEndpointName ( dev );
        if ( USBConfiguration ( prependSystemName(device).c_str() ).testOpen() )
            result.add_answer(device.c_str(),device.c_str());
    }
    for ( dev = 0 ; dev < 9 ; ++dev )
    {
        std::string device = WidcommEndpointName ( dev );
        if ( USBConfiguration ( prependSystemName(device).c_str() ).testOpen() )
            result.add_answer(device.c_str(),device.c_str());
    }
    return result;
}
#endif

static const char * nothing = "none";
#ifdef USE_FIXED_ENUMERATION
Question enumerateTransports( bool allow_none )
{
  PreformedQuestion protocols ( protocolName );

  Question ports = enumeratePorts();

  Question endpoints = enumerateUSB();

  protocols.add_answer(bcspName,ports);
  protocols.add_answer(usbName,endpoints);
  protocols.add_answer(h4Name,ports);
  protocols.add_answer(h4dsName,ports);
  protocols.add_answer(h5Name,ports);
  // Allow no connection at all
  if ( allow_none )
      protocols.add_answer(nothing, nothing);

  return protocols;
}
#endif

std::pair<bool,TransportConfigurationPtr> createTransportConfig ( const Answer &path )
{
    bool ok = false;
    TransportConfigurationPtr lConfig(0);
    TransportConfiguration::Protocol lProtocol;
    std::string lDeviceName;
    int lBaudRate;
    Answer::const_iterator ptr = path.begin();
    if ( ptr != path.end() )
    {
        //  top level is valid.
        std::string protocol_string = *ptr;
        if ( protocol_string == bcspName.key() )
            lProtocol = TransportConfiguration::BCSP;
        else if ( protocol_string == h4Name.key() )
            lProtocol = TransportConfiguration::H4;
        else if ( protocol_string == h4dsName.key() )
            lProtocol = TransportConfiguration::H4DS;
        else if ( protocol_string == usbName.key() )
            lProtocol = TransportConfiguration::USB;
        else if ( protocol_string == h5Name.key() )
            lProtocol = TransportConfiguration::H5;
        else
            lProtocol = TransportConfiguration::NONE;

        if ( lProtocol != TransportConfiguration::NONE && path.end() != ++ptr )
        {
#ifndef _WIN32_WCE
            istring lDeviceName = iwiden(prependSystemName(*ptr));
#else
            istring lDeviceName = iwiden(*ptr);
#endif
			switch ( lProtocol )
            {
            case TransportConfiguration::BCSP:
            case TransportConfiguration::H4:
            case TransportConfiguration::H4DS:
            case TransportConfiguration::H5:
                if ( lDeviceName[4] != 'p' )
                {
                    //  there's still a baud rate to come...
                    if ( path.end() != ++ptr )
                    {
                        lBaudRate = atoi ( (*ptr).c_str() );
                        if ( lProtocol == TransportConfiguration::BCSP )
                            lConfig = TransportConfigurationPtr ( new BCSPConfiguration ( lDeviceName.c_str() , lBaudRate ) );
                        else if ( lProtocol == TransportConfiguration::H5 )
                            lConfig = TransportConfigurationPtr ( new H5Configuration ( lDeviceName.c_str() , lBaudRate ) );
                        else if ( lProtocol == TransportConfiguration::H4DS )
                            lConfig = TransportConfigurationPtr ( new H4DSConfiguration ( lDeviceName.c_str() , lBaudRate ) );
                        else
                            lConfig = TransportConfigurationPtr ( new H4Configuration ( lDeviceName.c_str() , lBaudRate ) );
                        ok = true;
                    }
                }
#ifndef _WIN32_WCE
                else
                {
                    //  it's a pipe.
                    if ( lProtocol == TransportConfiguration::BCSP )
                        lConfig = TransportConfigurationPtr ( new BCSPConfiguration ( UARTConfiguration ( lDeviceName.c_str() ) ) );
                    else
                        lConfig = TransportConfigurationPtr ( new H4Configuration ( UARTConfiguration ( lDeviceName.c_str() ) ) );
                    ok = true;
                }
#endif
                break;
#ifndef _WIN32_WCE
            case TransportConfiguration::USB:
                lConfig = TransportConfigurationPtr ( new H2Configuration ( USBConfiguration ( lDeviceName.c_str() ) ) );
                ok = true;
                break;
#endif
            default:
                break;
            }
        }
    }
    return std::pair<bool,TransportConfigurationPtr> ( ok , lConfig );
}

#ifndef USE_FIXED_ENUMERATION
///////////////////////////////////////////////////////////////////////////////
//  Enumerate as you go construction
///////////////////////////////////////////////////////////////////////////////

static Question whatComport;
static Question whatUSBDevice;

class KeyMatch
{
public:
    KeyMatch ( const std::string& s )
    : str ( s ) {}
    bool operator() ( const MenuPair& i ) const
    { return str == i.key(); }
private:
    const std::string str;
};

class ComportQuestion : public QuestionImplementation
{
public:
    ComportQuestion() : QuestionImplementation ( portName )
    {
        std::vector<std::string> ports = UARTConfiguration::getListOfUarts();
        std::vector<std::string>::iterator i;
        for ( i = ports.begin(); i != ports.end() ; ++i )
        {
            items.push_back(MenuPair(i->c_str(),i->c_str()));
        }
    }
    QuestionImplementation * clone() const
    { return new ComportQuestion; }
    MenuPairIt replies_begin() const
    { return items.begin(); }
    MenuPairIt replies_end() const
    { return items.end(); }
    const Question follow_on (const std::string& reply_key) const
    {
        MenuPairIt i = std::find_if ( items.begin(),
                                      items.end(),
                                      KeyMatch ( reply_key ) );
        if ( i != items.end() )
        {
            std::map<std::string,Question>::iterator j = port_speeds.find(i->key());
            if ( j == port_speeds.end() )
                port_speeds[i->key()] = create_baudrate_question(i->key());
            return port_speeds[i->key()];
        }
        else
            return 0;
    }
    const Question create_baudrate_question ( const std::string& com ) const
    {
        if ( com.substr(0,4) == "pipe" )
            return terminal;
        return enumerateSpeeds(com);
    }
private:
    std::list<MenuPair> items;
    mutable std::map<std::string,Question> port_speeds;
};

class USBDeviceQuestion : public QuestionImplementation
{
public:
    USBDeviceQuestion() : QuestionImplementation ( endpointName )
    {
    }
    QuestionImplementation * clone() const
    { return new USBDeviceQuestion; }
    MenuPairIt replies_begin() const
    { return items.begin(); }
    MenuPairIt replies_end() const
    { return items.end(); }
    const Question follow_on (const std::string& reply_key) const
    {
        return 0;
    }
private:
    std::list<MenuPair> items;
};

static class ProtocolQuestion : public QuestionImplementation
{
public:
    ProtocolQuestion() : QuestionImplementation ( protocolName )
    {
        items.push_back(bcspName);
        items.push_back(h4Name);
        items.push_back(h4dsName);
        items.push_back(h5Name);
        items.push_back(usbName);
    }
    QuestionImplementation * clone() const
    { return new ProtocolQuestion; }
    MenuPairIt replies_begin() const
    { return items.begin(); }
    MenuPairIt replies_end() const
    { return items.end(); }
    const Question follow_on (const std::string& reply_key) const
    {
        if ( reply_key == bcspName.key()
          || reply_key == h4Name.key()
		  || reply_key == h4dsName.key()
          || reply_key == h5Name.key() )
        {
            if ( !whatComport )
                whatComport = new ComportQuestion;
            return whatComport;
        }
#ifndef _WIN32_WCE
        else if ( reply_key == usbName.key() )
        {
            //if ( !whatUSBDevice )
            //    whatUSBDevice = new USBDeviceQuestion;
            return enumerateUSB(); //whatUSBDevice;
        }
#endif
        else
            return 0;
    }
private:
    std::list<MenuPair> items;
} gProtocol;

const Question whatTransport (gProtocol);

/*
 * Transports to be put in menu in gui come from gProtocol. This won't be
 * obvious if you are stepping through the program with the debugger starting
 * from InitInstance because gProtocol is global.
 */
Question enumerateTransports( bool allow_none )
{
  return whatTransport;
}
#endif
