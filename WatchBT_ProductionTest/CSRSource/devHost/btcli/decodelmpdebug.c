// Copyright (C) 2000-2006 Cambridge Silicon Radio Ltd.; all rights reserved.
// Decoding of received LMP debug data (including LMP FSM debug).
// $Id: //depot/bc/bluesuite_2_4/devHost/btcli/decodelmpdebug.c#1 $


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if !defined(_WINCE) && !defined(_WIN32_WCE)
#include <assert.h>
#define ASSERT assert
#else
#include "wince/wincefuncs.h"
#endif

#include "print.h"
#include "dictionaries.h"
#include "constants.h" /* For NUL */
#include "globals.h"
#include "btcli.h"

static ichar **fsm_state_names[17], **fsm_event_names[17];
static size_t n_fsm_state_names[17], n_fsm_event_names[17];

#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

static size_t slurpFSMdataOneHalf (const ichar *leafname, FILE *f, ichar ***slurpto, const ichar *type, const ichar *type2)
{
	ichar line[256], *name;
	size_t n = 0;

	*slurpto = NULL;

	for (;;)
	{
		if (ifgets (line, sizeof (line) / sizeof (ichar), f) == NULL)
		{
			iprintlf (II("%s: failed to find %s names!\n"), leafname, type);
			goto disaster;
		}
		if (istrncmp (line, II("const char"), istrlen (II("const char"))) == 0 &&
		    istrstr (line, type2) != NULL)
		{
			break;
		}
	}

	/* Try to make sure CP/M EOLs won't trip us up! */
	ASSERT (line[istrlen (line) - 1] == '\n' || line[istrlen (line) - 1] == '\r');
	if (ifgets (line, sizeof (line) / sizeof (ichar), f) == NULL)
	{
		iprintlf (II("%s: %s name list corrupt!\n"), leafname, type);
		goto disaster;
	}
	ASSERT (istrncmp (line, II("{"), istrlen (II("{"))) == 0);
	ASSERT (line[istrlen (line) - 1] == '\n' || line[istrlen (line) - 1] == '\r');

	for (;;)
	{
		if (ifgets (line, sizeof (line) / sizeof (ichar), f) == NULL)
		{
			iprintlf (II("%s: %s name list truncated!\n"), leafname, type);
			goto disaster;
		}
		if (istrncmp (line, II("};"), istrlen (II("};"))) == 0)
		{
			break;
		}
		name = istrchr (line, '\"');
		if (name == NULL)
		{
			iprintlf (II("%s: %s name start missing!\n"), leafname, type);
			goto disaster;
		}
		++name;
		if (istrrchr (name, '\"') == NULL)
		{
			iprintlf (II("%s: %s name end missing!\n"), leafname, type);
			goto disaster;
		}
		*istrrchr (name, '\"') = NUL;
		if (istrncmp (name, II("LM_"), istrlen (II("LM_"))) != 0)
		{
			iprintlf (II("%s: %s name doesn't start with 'LM_'!\n"), leafname, type);
			goto disaster;
		}
		name += istrlen (II("LM_"));
		*slurpto = realloc (*slurpto, (n + 1) * sizeof (**slurpto));
		ASSERT (*slurpto != NULL);
		(*slurpto)[n] = malloc ((istrlen (name) + 1) * sizeof (ichar));
		ASSERT ((*slurpto)[n] != NULL);
		istrcpy ((*slurpto)[n], name);
		++n;
	}

	return n;

	disaster:

	if (*slurpto != NULL)
	{
		while (n--)
		{
			free ((*slurpto)[n]);
		}
		free (*slurpto);
		*slurpto = NULL;
	}
	return 0;
}


static bool loadFSMdataOne (const ichar *fsmdir, const ichar *leafname, unsigned fsm)
{
	FILE *f;
	ichar *newleafname;

	if (fsmdir != NULL)
	{
		newleafname = malloc ((istrlen (fsmdir) + 1 + istrlen (leafname) + 1) * sizeof (ichar));
		ASSERT (newleafname != NULL);
		istrcpy (newleafname, fsmdir);
#ifdef _WIN32
		istrcat (newleafname, II("\\"));
#else
		istrcat (newleafname, II("/"));
#endif
		istrcat (newleafname, leafname);
		leafname = newleafname;
	}

	f = ifopen (leafname, II("r"));
	if (f == NULL)
	{
		return false;
	}

	if ((n_fsm_state_names[fsm] = slurpFSMdataOneHalf (leafname, f, &fsm_state_names[fsm], II("state"), II("state_names"))) != 0)
	{
		n_fsm_event_names[fsm] = slurpFSMdataOneHalf (leafname, f, &fsm_event_names[fsm], II("event"), II("event_names"));
	}

#ifdef MGRCHECKFSMDATASLURPING
{
	size_t i;
	iprintf (II("%s %s names (%lu names):\n"), leafname, II("state"), (ul) n_fsm_state_names[fsm]);
	for (i = 0; i < n_fsm_state_names[fsm]; ++i)
		iprintf (II("%s\n"), fsm_state_names[fsm][i]);
	iprintf (II("%s %s names (%lu names):\n"), leafname, II("event"), (ul) n_fsm_event_names[fsm]);
	for (i = 0; i < n_fsm_event_names[fsm]; ++i)
		iprintf (II("%s\n"), fsm_event_names[fsm][i]);
}
#endif

	if (fsmdir != NULL)
	{
		free (newleafname);
	}

	fclose (f);
	return true;
}


void loadFSMdata (const ichar *fsmdir)
{
	if (fsmdir == NULL)
	{
		fsmdir = igetenv (II("FSMDIR"));
	}
	/* Rule here is if the *_constants.h fails to load, try constants.c 
	 * because of B-14094 Autogenerated FSM header files are poorly designed.
	 */
	if (!loadFSMdataOne (fsmdir, II("lm_slave_fsm_constants.h"), 0))
		loadFSMdataOne (fsmdir, II("lm_slave_fsm_constants.c"), 0);

	if (!loadFSMdataOne (fsmdir, II("lm_master_fsm_constants.h"), 1))
		loadFSMdataOne (fsmdir, II("lm_master_fsm_constants.c"), 1);

	if (!loadFSMdataOne (fsmdir, II("lm_device_fsm_constants.h"), 2))
		loadFSMdataOne (fsmdir, II("lm_device_fsm_constants.c"), 2);

	if (!loadFSMdataOne (fsmdir, II("lm_power_fsm_constants.h"), 3))
		loadFSMdataOne (fsmdir, II("lm_power_fsm_constants.c"), 3);

	if (!loadFSMdataOne (fsmdir, II("lm_init_auth_fsm_constants.h"), 4))
		loadFSMdataOne (fsmdir, II("lm_init_auth_fsm_constants.c"), 4);

	if (!loadFSMdataOne (fsmdir, II("lm_respond_auth_fsm_constants.h"), 5))
		loadFSMdataOne (fsmdir, II("lm_respond_auth_fsm_constants.c"), 5);

	if (!loadFSMdataOne (fsmdir, II("lm_bdw_fsm_constants.h"), 6))
		loadFSMdataOne (fsmdir, II("lm_bdw_fsm_constants.c"), 6);

	if (!loadFSMdataOne (fsmdir, II("lm_mlk_fsm_constants.h"), 7))
		loadFSMdataOne (fsmdir, II("lm_mlk_fsm_constants.c"), 7);

	if (!loadFSMdataOne (fsmdir, II("lm_slave_enc_fsm_constants.h"), 8))
		loadFSMdataOne (fsmdir, II("lm_slave_enc_fsm_constants.c"), 8);

	if (!loadFSMdataOne (fsmdir, II("lm_master_enc_fsm_constants.h"), 9))
		loadFSMdataOne (fsmdir, II("lm_master_enc_fsm_constants.c"), 9);

	if (!loadFSMdataOne (fsmdir, II("lm_rnr_fsm_constants.h"), 10))
		loadFSMdataOne (fsmdir, II("lm_rnr_fsm_constants.c"), 10);

	if (!loadFSMdataOne (fsmdir, II("lm_afh_fsm_constants.h"), 11))
		loadFSMdataOne (fsmdir, II("lm_afh_fsm_constants.c"), 11);

	if (!loadFSMdataOne (fsmdir, II("lm_scattermode_fsm_constants.h"), 12))
		loadFSMdataOne (fsmdir, II("lm_scattermode_fsm_constants.c"), 12);
	
	if (!loadFSMdataOne (fsmdir, II("lm_ulp_m_init_fsm_constants.h"), HCI_DEBUG_EV_FSM_LM_ULP_MASTER_INIT))
		loadFSMdataOne (fsmdir, II("lm_ulp_m_init_fsm_constants.c"), HCI_DEBUG_EV_FSM_LM_ULP_MASTER_INIT);

	if (!loadFSMdataOne (fsmdir, II("lm_ulp_m_resp_fsm_constants.h"), HCI_DEBUG_EV_FSM_LM_ULP_MASTER_RESP))
		loadFSMdataOne (fsmdir, II("lm_ulp_m_resp_fsm_constants.c"), HCI_DEBUG_EV_FSM_LM_ULP_MASTER_RESP);
        
	if (!loadFSMdataOne (fsmdir, II("lm_ulp_s_init_fsm_constants.h"), HCI_DEBUG_EV_FSM_LM_ULP_SLAVE_INIT))
		loadFSMdataOne (fsmdir, II("lm_ulp_s_init_fsm_constants.c"), HCI_DEBUG_EV_FSM_LM_ULP_SLAVE_INIT);

	if (!loadFSMdataOne (fsmdir, II("lm_ulp_s_resp_fsm_constants.h"), HCI_DEBUG_EV_FSM_LM_ULP_SLAVE_RESP))
		loadFSMdataOne (fsmdir, II("lm_ulp_s_resp_fsm_constants.c"), HCI_DEBUG_EV_FSM_LM_ULP_SLAVE_RESP);
}


static void printStateAndEvent (unsigned fsm, unsigned state, unsigned event)
{
	bool validfsm = fsm < sizeof (n_fsm_state_names) / sizeof (n_fsm_state_names[0]);

	if (validfsm && state < n_fsm_state_names[fsm])
	{
		iprintlf (II(" %s"), fsm_state_names[fsm][state]);
	}
	else
	{
		iprintlf (II(" st:%u"), state);
	}

	if (validfsm && event < n_fsm_event_names[fsm])
	{
		iprintlf (II(" %s"), fsm_event_names[fsm][event]);
	}
#define NOEVENT ((unsigned) -1)
	else if (event != NOEVENT)
	{
		iprintlf (II(" ev:%u"), event);
	}
}


static void printBigHex (const u8 *buf, unsigned len, const char *prefix)
{
	printlf ("%s:0x", prefix);
	buf += len;
	while (len-- != 0)
	{
		printlf ("%02x", *--buf);
	}
}


static u32 decodeULPAdvDebug(const u8 *buf, u32 len)
{
	u8 advType = buf[1];
	printlf(" ");
	printByValue(ulpAdvDebug_d, advType, 8, "unknown");
	printlf(" ");
	len--;
	switch (advType & ~HCI_DEBUG_EV_ULP_ADV_CHAN_TX)
	{
	case HCI_DEBUG_EV_ULP_ADV_CHAN_CONN_REQ_PT1:
		printlf("chan:%d", buf[4]);
		printByValue(NULL, buf[3], 8, " hdr");
		printlf(" ");
		printba (buf[6] | (buf[5] << 8) | ((u32) buf[8] << 16), buf[7], buf[10] | (buf[9] << 8));
		printByValue(NULL, buf[11] | (buf[12] << 8) | (buf[13] << 16) | (buf[14] << 24), 32, " aa");
		printByValue(NULL, buf[15] | (buf[16] << 8) | (buf[17] << 16), 24, " ci");
		printByValue(NULL, buf[18], 8, " ws");
		len = 0;
		break;

	case HCI_DEBUG_EV_ULP_ADV_CHAN_CONN_REQ_PT2:
		printByValue(NULL, buf[3] | (buf[4] << 8), 16, "wo");
		printByValue(NULL, buf[5] | (buf[6] << 8), 16, " i");
		printByValue(NULL, buf[7] | (buf[8] << 8), 16, " l");
		printByValue(NULL, buf[9] | (buf[10] << 8), 16, " to");
		printBigHex (&buf[11], 5, " chm");
		printByValue(NULL, buf[16] & 0x1f, 5, " h");
		printByValue(NULL, buf[16] >> 5, 3, " sca");
		len = 0;
		break;
	}
	return len;
}

void decodeLMPdebug (const u8 *buf, u32 len, char *whoami)
{
	size_t i = 1;
	static u8 encapsulated_pdu_length = 0;
	ASSERT (len == 1 + 9 * 2);
	len = 18;

    /*  Eliminate unwanted messages based on opt flags (also ACL and SCO based
     * on channel information)
     *
     *  Although promulgates use of magic numbers, necessary as adding checks
     * below over complicates the output logic 
     */
    switch (buf[0])
    {
    case HCI_DEBUG_EV_RX_LMP:
    case HCI_DEBUG_EV_TX_LMP:
        {
            u16 o = buf[1] >> 1;
            if (124 <= o && o <= 127) /* Extended op-code; 1.2 only */
            {
                 o = (o << 8) | buf[2];
            }
    
            switch (o)
            {
            case 31:    /* LMP_*power* */
            case 32:
            case 33:
            case 34:
            case 0x7F1f:
            case 0x7F20:
                if (!showLMPpower)
                    return;
                break;
        
            case 36:    /* LMP_preferred_rate */
                if (!showLMPcqddr && !showLMPcqddr2)
                    return;
                break;
        
            case 60:
            case 0x7F10: /* LMP_channel_classification req */
            case 0x7F11: /* LMP_channel_classification rsp */
                if (!showAfh)
                    return;
                break;
            }
            break;
        }

    case HCI_DEBUG_EV_CQDDR:
    case HCI_DEBUG_EV_SLOTS:
        if (!showLMPcqddr)
            return;
        break;

    case HCI_DEBUG_EV_PKT_TYPES:
        if (!showLMPcqddr && !showLMPcqddr2)
            return;
        break;

    case HCI_DEBUG_EV_ACL:
        if ((buf[11] | (buf[12] << 8)) == 0x0000)
            return;
        break;
        
    case HCI_DEBUG_EV_SCO:
        if ((buf[3] | (buf[4] << 8)) == 0xffff)
            return;
        break;

    case HCI_DEBUG_EV_TO:
    case HCI_DEBUG_EV_TO_START:
    case HCI_DEBUG_EV_TO_CANCEL:
    case HCI_DEBUG_EV_TO_LOST:
        if (    !showAfh 
            && ((buf[5] | (buf[6] << 8)) == 0x5555))
        {
            return;
        }
        break;

    case HCI_DEBUG_EV_FSM:
        {
        int fsm_id = buf[1] | (buf[2] << 8);

            if (!showAfh)
            {
                /* Save the ID of the fsm state machine as a static to avoid
                 * constantly looking up (don't use a magic number for once 
                 * as although unlikely to change, a dictionary is available
                 */
                static u32 afh_fsm_id = -1;
                if (afh_fsm_id == -1)
                {
                    if (!lookupByName(fsm_d,"afh",&afh_fsm_id))
                        afh_fsm_id = -2;
                }
                /* No need to worry about the -1/-2 markers as unlikely to 
                 * get to 4 billion different FSMs 
                 */
                if (afh_fsm_id == fsm_id)
                {
                    return;
                }
            }
            if (!showLMPpower)
            {
                static u32 power_fsm_id = -1;
                if (power_fsm_id == -1)
                {
                    if (!lookupByName(fsm_d,"power",&power_fsm_id))
                        power_fsm_id = -2;
                }
                if (power_fsm_id == fsm_id)
                {
                    return;
                }
            }
            break;
        }
    }

    printTimestamp ();
    printlf (" ");

    {
		switch (buf[0])
	    {
        case HCI_DEBUG_EV_LC_SCO_SELECT_D_INIT:
        case HCI_DEBUG_EV_LC_SCO_SELECT_D_NEXT:
        case HCI_DEBUG_EV_LC_SCO_SELECT_D_END:
        case HCI_DEBUG_EV_LC_ADD_SCO:
        case HCI_DEBUG_EV_LC_REMOVE_SCO:
        case HCI_DEBUG_EV_LC_SCO_REMOVED:
        case HCI_DEBUG_EV_LC_CHANGE_SCO:
        case HCI_DEBUG_EV_LC_SCO_CHECK:
        case HCI_DEBUG_EV_LC_PAUSE_USER_DATA:
            break;

        default:
            printByValue (lmpDebug_d, buf[0], 8, "lm_debug");
            break;
        }
    }

	switch (buf[0])
	{
	case HCI_DEBUG_EV_DRAIN:
		/* This outputs s debug message usefull for debugging the drain subsystem.
		   The 'num' is the index of the timer or counter.  The large number is the
		   counter total since this command was last executed.  The firsr pair of
		   numbers is the first number expressed in the internal floating point
		   format.  The secound pair of numbers is the current scale value for this
		   timer.
		*/
        printlf(" num:0x%2.2x  0x%8.8x  0x%4.4x:0x%4.4x  0x%4.4x:0x%4.4x",
			buf[ 1],
			buf[ 5] | ((u32)buf[ 6] << 8) | ((u32)buf[3] << 16) | ((u32)buf[4] << 24),
			buf[ 7] | ((u32)buf[ 8] << 8),
			buf[ 9] | ((u32)buf[10] << 8),
			buf[11] | ((u32)buf[12] << 8),
			buf[13] | ((u32)buf[14] << 8));
        len = 0;
        break;

	case HCI_DEBUG_EV_FSM:

		printlf (" ");
		printByValue (fsm_d, buf[1] | (buf[2] << 8), 16, "sm");
		printStateAndEvent (buf[1] | (buf[2] << 8), buf[3] | (buf[4] << 8), buf[5] | (buf[6] << 8));

		len = 0;
		break;

	case HCI_DEBUG_EV_ACL:

		printlf (" ");
		printByValue (fsm_d, buf[1] | (buf[2] << 8), 16, "sm");
		printlf (" ");
		printba (buf[15] | (buf[16] << 8) | ((u32) buf[13] << 16), buf[3], buf[9] | (buf[10] << 8));
		printlf (" ");
		printch (buf[11] | (buf[12] << 8));
		printlf (" ");
		printByValue (NULL, buf[17], 8, "pm");
		printlf (" ");
		printByValue (NULL, buf[18], 8, "ar");
		printStateAndEvent (buf[1] | (buf[2] << 8), buf[5] | (buf[6] << 8), NOEVENT);
		printStateAndEvent (buf[1] | (buf[2] << 8), buf[7] | (buf[8] << 8), NOEVENT);

		len = 0;
		break;

	case HCI_DEBUG_EV_SCO:

		printlf (" ");
		printch (buf[3] | (buf[4] << 8));
		printlf (" ");
		printch (buf[7] | (buf[8] << 8));
		printlf (" ");
		printByValue (NULL, buf[5], 8, "sh");
		printlf (" ");
		printByValue (scoPacket_d, buf[9], 8, "sp");
		printlf (" ");
		printByValue (packetType_d, buf[11] | (buf[12] << 8), 16, "pt");
		printlf (" ");
		printByValue (NULL, buf[13], 8, "ds_i1");
		printlf (" ");
		printByValue (NULL, buf[15], 8, "ds_i2");
		printlf (" ");

		len = 0;
		break;

	case HCI_DEBUG_EV_ESCO:

		printlf (" ");
		printch (buf[3] | (buf[4] << 8));
		printlf (" ");
		printch (buf[7] | (buf[8] << 8));
		printlf (" ");
		printByValue (NULL, buf[5], 8, "lsh");
		printlf (" ");
		printByValue (NULL, buf[9] | (buf[10] << 8), 16, "pkts");
		printlf (" ");
		printByValue (NULL, buf[11] | (buf[12] << 8), 16, "latency");
		printlf (" ");
		printByValue (NULL, buf[13] | (buf[14] << 8), 8, "voice");
		printlf (" ");

		len = 0;
		break;

	case HCI_DEBUG_EV_ULP_ACL_MASTER:
	case HCI_DEBUG_EV_ULP_ACL_SLAVE:
		printlf(" ");
		printAddressType(buf[3]);
		printlf(" ");
	    printba (buf[7] | (buf[8] << 8) | ((u32) buf[5] << 16), buf[4], buf[1] | (buf[2] << 8));
		printlf(" ");
		printch (buf[9] | (buf[10] << 8));
		printByValue(NULL, buf[11] | (buf[12] << 8), 16, " i");
		printByValue(NULL, buf[13] | (buf[14] << 8), 16, " l");
		if (buf[0] == HCI_DEBUG_EV_ULP_ACL_MASTER)
		{
			printStateAndEvent(HCI_DEBUG_EV_FSM_LM_ULP_MASTER_INIT, buf[15] | (buf[16] << 8), NOEVENT);
			printStateAndEvent(HCI_DEBUG_EV_FSM_LM_ULP_MASTER_RESP, buf[17] | (buf[18] << 8), NOEVENT);
		}
		else
		{
			printStateAndEvent(HCI_DEBUG_EV_FSM_LM_ULP_SLAVE_INIT, buf[15] | (buf[16] << 8), NOEVENT);
			printStateAndEvent(HCI_DEBUG_EV_FSM_LM_ULP_SLAVE_RESP, buf[17] | (buf[18] << 8), NOEVENT);
		}
		len -= 18;
		break;

    case HCI_DEBUG_EV_ULP_INST_UPDATED:
        {
            u16 new_instant = (u16)((buf[4] << 8) | buf[3]);
            printlf(" ");
            printch((u32)(buf[2]));
            printlf(" updated_count:0x%.4x", new_instant);
            len = 0;
            break;
        }
    
    case HCI_DEBUG_EV_LC_SCO_SELECT_D_INIT:
    case HCI_DEBUG_EV_LC_SCO_SELECT_D_NEXT:
    case HCI_DEBUG_EV_LC_SCO_SELECT_D_END:
    case HCI_DEBUG_EV_LC_ADD_SCO:
    case HCI_DEBUG_EV_LC_REMOVE_SCO:
    case HCI_DEBUG_EV_LC_SCO_REMOVED:
    case HCI_DEBUG_EV_LC_CHANGE_SCO:
    case HCI_DEBUG_EV_LC_SCO_CHECK:
		printByValue (lc_esco_debug_d, buf[0], 8, "fn"); /* LC function */
		printlf (" ");
		printByValue (NULL, buf[1], 8, "h"); /* ACL id */
		printlf (" ");
		printByValue (NULL, buf[2], 8, "lsh"); /* LMP SCO handle */
		printlf (" ");
		printByValue (NULL, buf[3], 8, "addr");
		printlf (" ");
		printByValue (NULL, buf[4], 8, "sh");
		printlf (" ");
		printByValue (NULL, buf[5], 8, "t");
		printlf (" ");
		printByValue (NULL, buf[6], 8, "d");
		printlf (" ");
		printByValue (NULL, buf[7], 8, "w");
		printlf (" ");
		printByValue (NULL, buf[8], 8, "rw");
		printlf (" ");
		printByValue (NULL, buf[9], 8, "f");
		printlf (" ");
		printByValue (airMode_d, buf[10], 8, "am");
		printlf (" ");
		printByValue (escoPacket_d, buf[11], 8, "pts2m");
		printlf (" ");
		printByValue (escoPacket_d, buf[12], 8, "ptm2s");
		printlf (" ");
		printByValue (NULL, buf[13], 8, "pls2m");
		printlf (" ");
		printByValue (NULL, buf[14], 8, "plm2s");
		printlf (" ");
		printByValue (linkType_d, buf[15], 8, "lt");
		printlf (" ");
		printByValue (lm_esco_ns_d, buf[16], 8, "ns");
		len = 0;
		break;

	case HCI_DEBUG_EV_LC_PAUSE_USER_DATA:
		printByValue (lc_esco_debug_d, buf[0], 8, "fn"); /* LC function */
		printlf (" ");
		if (buf[2] == 0xff)
		{
		    printlf ("all_user_data_paused");
		}
		else
		{
		    printch(buf[1]); /* ACL id */
		    printlf (" ");
		    printByValue (pause_d, buf[2], 8, "reason");
		    printlf (" ");
		    printByValue (NULL, buf[3], 8, "callback");
		    printlf (" ");
		    printByValue (NULL, buf[6] << 8 | buf[5], 16, "count");
		    if (buf[6] > 0x80)
			printlf ("\n*** Error: semaphore count has wrapped\n");
		}
		len = 0;
		break;

	case HCI_DEBUG_EV_ESCO_NEGOTIATION:
		printlf (" ");
		printByValue (NULL, buf[1] | (buf[2] << 8), 16, "tesco");
		printlf (" ");
		printByValue (NULL, buf[3] | (buf[4] << 8), 16, "wesco");
		printlf (" ");
		printByValue (NULL, buf[5] | (buf[6] << 8), 16, "m2spl");
		printlf (" ");
		printByValue (NULL, buf[7] | (buf[8] << 8), 16, "s2mpl");
		printlf (" ");
		printByValue (NULL, buf[9] | (buf[10] << 8), 16, "rw");
		printlf (" ");
		printByValue (NULL, buf[11] | (buf[12] << 8), 16, "re");
		printlf (" m2sbdw:%d", buf[13] | (buf[14] << 8));
		printlf (" s2mbdw:%d", buf[15] | (buf[16] << 8));
		printlf (" latency:%dms", buf[17] | (buf[18] << 8));
		printlf (" ");

		len = 0;
		break;

	case HCI_DEBUG_EV_PARKED:

		printlf (" ");
		printch (buf[3] | (buf[4] << 8));
		printlf (" ");
		printByValue (NULL, buf[5], 8, "pm");
		printlf (" ");
		printByValue (NULL, buf[7], 8, "ar");

		len = 0;
		break;

	case HCI_DEBUG_EV_MEM:

		if (buf[1] == 0 && buf[2] == 0)
		{
			printlf (" ");
			printByValue (NULL, buf[3] | (buf[4] << 8), 16, "ntot");
			printlf (" ");
			printByValue (NULL, buf[13] | (buf[14] << 8), 16, "sopdt");
			printlf (" ");
			printByValue (NULL, buf[15] | (buf[16] << 8), 16, "soldt");
			printlf (" ");
			printByValue (NULL, buf[17] | (buf[18] << 8), 16, "solt");
		}
		else
		{
			printlf (" ");
			printByValue (NULL, buf[1] | (buf[2] << 8), 16, "es");
			printlf (" ");
			printByValue (NULL, buf[3] | (buf[4] << 8), 16, "ne");
			printlf (" ");
/*			printByValue (NULL, buf[5] | (buf[6] << 8), 16, "ps");
			printlf (" "); */
			printByValue (NULL, buf[9] | (buf[10] << 8), 16, "nt");
			if ((buf[11] | (buf[12] << 8)) != 0xffff)
			{
				printlf (" ");
				printByValue (NULL, buf[11] | (buf[12] << 8), 16, "mt");
			}
			if ((buf[13] | (buf[14] << 8)) != 0xffff)
			{
				printlf (" ");
				printByValue (NULL, buf[13] | (buf[14] << 8), 16, "no");
			}
		}

		len = 0;
		break;

	case HCI_DEBUG_EV_STATS:

		/* Apparently unused */
		break;

	case HCI_DEBUG_EV_RAND:
	case HCI_DEBUG_EV_KEY:
	{
		int i;

		printlf (" 0x");
		for (i = 16; i > 0; --i)
		{
			printlf ("%02x", buf[i]);
		}

		len = 0;
		break;
	}

	case HCI_DEBUG_EV_SRES:
	{
		u32 sres, lap, uap, nap;

		sres =	buf[1] |
			((u32) buf[2] << 8) |
			((u32) buf[3] << 16) |
			((u32) buf[4] << 24);
		printlf (" sres:0x%04lx", (ul) sres);

		sres =	buf[5] |
			((u32) buf[6] << 8) |
			((u32) buf[7] << 16) |
			((u32) buf[8] << 24);
		printlf (" lm_sres:0x%04lx", (ul) sres);

		lap =	buf[13] |
			((u32) buf[14] << 8) |
			((u32) buf[15] << 16);
		uap =	buf[11];
		nap =	buf[9] |
			((u32) buf[10] << 8);

		printlf (" ");
		printba (lap, uap, nap);

		len = 0;
		break;
	}
	case HCI_DEBUG_EV_RX_LMP:
	case HCI_DEBUG_EV_TX_LMP:
	case HCI_DEBUG_EV_RX_LMP_DUPLICATE:
	{

		/* These tables are the lengths of the parameters for each LMP pdu */
		static u8 lmplen[] = {
			17 /* invalid */,
			2,  17, 2,  3,  1,  3,  2,  17, 17, 17,	/*  1..10 */
			17, 5,  17, 17, 2,  2,  17, 1,  5,  7,	/* 11..20 */
			7,  10, 10, 1,  17, 17, 6,  13, 17, 17, /* 21..30 */
			2,  2,  1,  1,  1,  2,  6,  6,  9,  9,	/* 31..40 */
			4,  4,  7,  3,  2,  2,  1,  3,  1,  1,	/* 41..50 */
			1,  9,  3,  3,  3,  1,  10, 1,  3,  16,	/* 51..60 */
			4,  17, 17, 17, 17			/* 61..65 */
		};
		static u8 lmplen127[] = {
			17 /* invalid */,
			 4,  5, 12, 12, 11,  3,  3,  2, 10,  3, /* 0x7f01..0x7f0a */
			 3, 16,  4, 17,  3,  7, 12, 10, 14, 10, /* 0x7f0b..0x7f14 */
			 9,  9,  2,  2,  4,  4,  2,  2,  2,  3 	/* 0x7f15..0x7f1e */
		};
		static u8 ulpllclen[] = {
			12, 8, 2, 23, 13, 1, 1, 2, 9, 9, 1, 1, 5, 2
		};
		int n = 0;
		u16 o = buf[i] >> 1;
		bool tid = buf[i++] & 1;
		bool showch = 
						true;
		len = 17 /* invalid */;
		if (124 <= o && o <= 127) /* Extended op-code; 1.2 only */
		{
			u8 q = buf[i++];
			if (o == 127 &&
			    q < sizeof (lmplen127) / sizeof (lmplen127[0]))
			{
				len = lmplen127[q];
			}
			o = (o << 8) | q;
		}
		else if (o < sizeof (lmplen) / sizeof (lmplen[0]))
		{
			if (o < 27 || o > 30) /* LMP broadcast park messages */
			{
				len = lmplen[o];
			}
			else
			{
				len = buf[18];
				showch = false;
			}
		}
		if (showch)
		{
			printlf (" ");
			printch (buf[18]);
			for (n = 0; n < 18; ++n)
			{ 
				if (buf[18] == aclch[n])
				{
					break;
				}
			}
		}
		if (showch == false || ulplink[n] == false) {
		printlf (" %c/", tid ? 's' : 'm');
		printByValue (lmp_d, o, 16, "o");
		switch (o)
		{
		case 1:
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "no");
			break;

		case 2:
		{
			int j;
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "no");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "nl");
			printlf (" \"");
			for (j = 0; j < 14; ++j)
			{
				printChar (buf[i++]);
			}
			printlf ("\"");
			break;
		}

		case 3:
			printlf (" ");
			printByValue (lmp_d, buf[i++], 8, "o");
			break;

		case 4:
			printlf (" ");
			printByValue (lmp_d, buf[i++], 8, "o");
			printlf (" ");
			printByValue (errorCode_d, buf[i++], 8, "r");
			break;

		case 6:
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "co");
			i += 2;
			break;

		case 7:
			printlf (" ");
			printByValue (errorCode_d, buf[i++], 8, "r");
			break;

		case 8:
		case 9:
		case 11:
		case 13:
		case 17:
			printlf (" ");
			printBigHex (&buf[i], 16, "rn");
			i += 16;
			break;

		case 10:
		case 14:
			printlf (" ");
			printBigHex (&buf[i], 16, "k");
			i += 16;
			break;

		case 12:
			printlf (" ");
			printBigHex (&buf[i], 4, "ar");
			i += 4;
			break;

		case 15:
			printlf (" ");
			printByValue (encryptionMode_d, buf[i++], 8, "em");
			break;

		case 16:
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "ks");
			break;

		case 19:
			printlf (" ");
			printBigHex (&buf[i], 4, "si");
			i += 4;
			break;

		case 20:
		case 21:
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "ht");
			i += 2;
			printlf (" ");
			printBigHex (&buf[i], 4, "hi");
			i += 4;
			break;

		case 23:
			printlf (" ");
			printByValue (i_d, buf[i++], 8, "tcf");
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "ds");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "ts");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "sa");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "st");
			i += 2;
			break;

		case 25:
			printlf (" ");
			printByValue (tcf_d, buf[i++], 8, "tcf");
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "db");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "tb");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "nb");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "deltab");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "pm");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "ar");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "nbs");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "dbs");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "da");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "ta");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "na");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "np");
			printlf (" ");
			printByValue (NULL, buf[i] & 0x0f, 8, "ma");
			printlf (" ");
			printByValue (NULL, buf[i++] >> 4, 8, "as");
			break;

		case 27:
			printlf (" ");
			printByValue (tcf_d, buf[i++], 8, "tcf");
			if (buf[i - 1] & 1)
			{
				printlf (" ");
				printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "db");
				i += 2;
			}
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "bsw");
			i += 2;
			len = 0; /* In case Db was absent */
			break;

		case 28:
			printlf (" ");
			printByValue (tcf_d, buf[i++], 8, "tcf");
			if (buf[i - 1] & 1)
			{
				printlf (" ");
				printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "db");
				i += 2;
			}
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "tb");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "nb");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "deltab");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "da");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "ta");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "na");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "np");
			printlf (" ");
			printByValue (NULL, buf[i] & 0x0f, 8, "ma");
			printlf (" ");
			printByValue (NULL, buf[i++] >> 4, 8, "as");
			len = 0; /* In case Db was absent */
			break;

		case 29:
		{
			bool wonky = false;
			u8 am;
			printlf (" ");
			printByValue (tcf_d, buf[i++], 8, "tcf");
			if (buf[i - 1] & 1)
			{
				printlf (" ");
				printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "db");
				i += 2;
			}
			am = buf[i++];
			printlf (" ");
			printByValue (NULL, am & 0x0f, 8, "am");
			if ((am & 0x0f) == 0)
			{
				wonky = true;
			}
			printlf (" ");
			printba (buf[i] | (buf[i + 1] << 8) | ((u32) buf[i + 2] << 16), buf[i + 3], buf[i + 4] | (buf[i + 5] << 8));
			i += 6;
			if ((am >> 4) != 0 || len != i - 1)
			{
				if ((am >> 4) == 0)
				{
					wonky = true;
				}
				printlf (" 2");
				printByValue (NULL, am >> 4, 8, "am");
				printlf (" 2");
				printba (buf[i] | (buf[i + 1] << 8) | ((u32) buf[i + 2] << 16), buf[i + 3], buf[i + 4] | (buf[i + 5] << 8));
				i += 6;
			}
			if (wonky || len != i - 1)
			{
				printlf (" (wonky: len %u)", len);
			}
			len = 0; /* In case Db was absent */
			break;
		}

		case 30:
		{
			bool wonky = false;
			u8 am;
			int j;
			printlf (" ");
			printByValue (tcf_d, buf[i++], 8, "tcf");
			if (buf[i - 1] & 1)
			{
				printlf (" ");
				printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "db");
				i += 2;
			}
			for (j = 1; j <= 7; ++j)
			{
				if (len <= i - 1) /* <= to catch broken Db */
				{
					wonky = true;
					break;
				}

				am = buf[i++];
				printlf (" ");
				if (j != 1)
				{
					printlf ("%i", j);
				}
				printByValue (NULL, am & 0x0f, 8, "am");
				if ((am & 0x0f) == 0)
				{
					wonky = true;
				}
				if (len == i - 1)
				{
					if (am >> 4)
					{
						printlf (" %i", j + 1);
						printByValue (NULL, am >> 4, 8, "am");
					}
					wonky = true;
					break;
				}

				printlf (" ");
				if (j != 1)
				{
					printlf ("%i", j);
				}
				printByValue (NULL, buf[i++], 8, "pm");
				if (len == i - 1)
				{
					if (am >> 4)
					{
						printlf (" %i", j + 1);
						printByValue (NULL, am >> 4, 8, "am");
						wonky = true;
					}
					break;
				}

				if (j == 7)
				{
					wonky = true;
				}
				++j;

				printlf (" %i", j);
				printByValue (NULL, am >> 4, 8, "am");
				printlf (" %i", j);
				printByValue (NULL, buf[i++], 8, "pm");
				if ((am >> 4) == 0)
				{
					wonky = true;
				}

				if (len == i - 1)
				{
					break;
				}
			}
			if (wonky || len != i - 1)
			{
				printlf (" (wonky: len %u)", len);
			}
			len = 0; /* In case Db was absent */
			break;
		}

		case 31:
		case 32:
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "ffu");
			break;

		case 36:
			printlf (" ");
			if (buf[i] > 7)
			{
				printByValue (NULL, buf[i++], 8, "pr");
			}
			else
			{
				printlf ("d%c", buf[i] & 1 ? 'h' : 'm');
				if (buf[i] > 1)
				{
					printlf ("%u", (buf[i] & 6) - 1);
				}
				++i;
			}
			break;

		case 37:
		case 38:
		{
			uint16 ci, svn;

			printlf (" ");
			printByValue (lmpVersion_d, buf[i++], 8, "pr");
			printlf (" ");
			ci = buf[i] | (buf[i + 1] << 8);
			printByValue (manufacturerName_d, ci, 16, "ci");
			i += 2;
			printlf (" ");
			svn = buf[i] | (buf[i + 1] << 8);
			printByValue (NULL, svn, 16, "svn");
			i += 2;
			if (ci == 0xa /* CSR */ &&
			    lookupByValue (id_d, svn))
			{
				printlf ("(");
				printByValue (id_d, svn, 16, NULL);
				printlf (")");
			}
			break;
		}

		case 39:
		case 40:
			printlf (" ");
			printBigHex (&buf[i], 8, "f");
			i += 8;
			break;

		case 41:
		case 42:
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "pi");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "nbc");
			break;

		case 43:
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "sh");
			printlf (" ");
			printByValue (i_d, buf[i++], 8, "tcf");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "ds");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "ts");
			printlf (" ");
			printByValue (scoPacket_d, buf[i++], 8, "sp");
			printlf (" ");
			printByValue (airMode_d, buf[i++], 8, "am");
			break;

		case 44:
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "sh");
			printlf (" ");
			printByValue (errorCode_d, buf[i++], 8, "r");
			break;

		case 45:
		case 46:
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "ms");
			break;

		case 48:
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "d");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "j");
			break;

		case 52:
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "so");
			i += 2;
			printlf (" ");
			printba (buf[i] | (buf[i + 1] << 8) | ((u32) buf[i + 2] << 16), buf[i + 3], buf[i + 4] | (buf[i + 5] << 8));
			i += 6;
			break;

		case 53:
		case 54:
			printlf (" ");
			printByValue (psm_d, buf[i++], 8, "ps");
			printlf (" ");
			printByValue (psrm_d, buf[i++], 8, "pss");
			break;

		case 55:
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "st");
			i += 2;
			break;

		case 57:
		{
			/*
			 * Note that in 1.1 these are all xored with 0x55.
			 * Use the pcm to guess whether this is the case.
			 */
			u8 xor = buf[i + 4] > 1 ? 0x55 : 0x00;
			printlf (" ");
			printByValue (testScenario_d, buf[i++] ^ xor, 8, "ts");
			printlf (" ");
			printByValue (hoppingMode_d, buf[i++] ^ xor, 8, "hm");
			printlf (" ");
			printByValue (NULL, buf[i++] ^ xor, 8, "tf");
			printlf (" ");
			printByValue (NULL, buf[i++] ^ xor, 8, "rf");
			printlf (" ");
			printByValue (powerControlMode_d, buf[i++] ^ xor, 8, "pcm");
			printlf (" ");
			printByValue (NULL, buf[i++] ^ xor, 8, "pp");
			printlf (" ");
			printByValue (testPacketType_d, buf[i++] ^ xor, 8, "pt");
			printlf (" ");
			printByValue (NULL, (buf[i] ^ xor) | ((buf[i + 1] ^ xor) << 8), 16, "lotd");
			i += 2;
			break;
		}

		case 59: /* LMP_encryption_key_size_mask_res; 1.2 only */
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "ksm");
			i += 2;
			break;

		case 60: /* LMP_set_AFH; 1.2 only */
		{
			unsigned f;

			printlf (" ");
			printBigHex (&buf[i], 4, "ai");
			i += 4;
			printlf (" ");
			printByValue (disabledEnabled_d, buf[i++], 8, "am");
			printlf (" ");
			printBigHex (&buf[i], 10, "acm");
			if (buf[i - 1] == 1) /* AFH_enabled */
			{
				printlf ("(");
				for (f = 0; f < 79; ++f)
				{
					if (f % 8 == 0 && f != 0)
					{
						printlf ("-");
					}
					printlf ("%u", buf[i + f / 8] >> (f % 8) & 1);
				}
				printlf (")");
			}
			i += 10;
			break;
		}

		case 61: /* Encapsulated Header */
		{
			u8 major = buf[i++];
			u8 minor = buf[i++];

			encapsulated_pdu_length = buf[i++];
			printlf (" ");
			printByValue (encapsulated_header_major_minor_d, minor | (major << 8), 16, "major:minor");
			printByValue (NULL, encapsulated_pdu_length, 8, " length");
		}
		break;

		case 62: /* Encapdulated Payload */
			/* If we have data length to process then display it */
			if (encapsulated_pdu_length != 0)
			{
				unsigned print_len;

				printlf(" data:");

				for(print_len = min(encapsulated_pdu_length, len-1);
					print_len != 0;
					print_len--)
				{
					printlf (" 0x%02x", buf[i++]);
				}

				/* If we've complete all we can and we've still some 
				 * left then must be padding 
				 */
				if (i <= len)
					printlf(" padding: ");
			}
			else
			{
				/* not seen header, all unknown */
				printlf(" unknown len data: ");
			}
			break;

		case 63: /* LMP_simple_pairing_confirm */
			printlf (" ");
			printBigHex (&buf[i], 16, "commit");
			i += 16;
			break;

		case 64: /* LMP_simple_pairing_number */
			printlf (" ");
			printBigHex (&buf[i], 16, "nonce");
			i += 16;
			break;

		case 65: /* LMP_dhkey_check */
			printlf (" ");
			printBigHex (&buf[i], 16, "confirm");
			i += 16;
			break;

		case 0x7f01: /* LMP_accepted_ext; 1.2 only */
			printlf (" ");
			printByValue (lmp_d, (buf[i] << 8) | buf[i + 1], 16, "o");
			i += 2;
			break;

		case 0x7f02: /* LMP_not_accepted_ext; 1.2 only */
			printlf (" ");
			printByValue (lmp_d, (buf[i] << 8) | buf[i + 1], 16, "o");
			i += 2;
			printlf (" ");
			printByValue (errorCode_d, buf[i++], 8, "r");
			break;

		case 0x7f03: /* LMP_features_req_ext; 1.2 only */
		case 0x7f04: /* LMP_features_res_ext; 1.2 only */
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "fp");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "msp");
			printlf (" ");
			printBigHex (&buf[i], 8, "ef");
			i += 8;
			break;

		case 0x7f05: /* LMP_scatter_req; 1.2 only */
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "ncet");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "npa");
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "tsp");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "tppa");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "dppa");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "sa"); /* HERE dictionary */
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "mppf"); /* HERE dictionary */
			printlf (" ");
			printByValue (i_d, buf[i++], 8, "tf");
			break;

		case 0x7f06: /* LMP_unscatter_req; 1.2 only */
			printlf (" ");
			printByValue (errorCode_d, buf[i++], 8, "r");
			break;

		case 0x7f07: /* LMP_set_subrate; 1.2 only */
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "nsl");
			break;

		case 0x7f09: /* LMP_scatter_algorithms_res; 1.2 only */
			printlf (" ");
			printBigHex (&buf[i], 8, "sam");
			i += 8;
			break;

		case 0x7f0a: /* LMP_PP_extension_req; 1.2 only */
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "npa");
			break;

		case 0x7f0b: /* LMP_packet_type_table_req; 1.3 only */
			printlf (" ");
			printByValue (ptt_d, buf[i++], 8, "ptt");
			break;

		case 0x7f0c: /* LMP_eSCO_link_req; 1.2 only */
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "eh");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "ela");
			printlf (" ");
			printByValue (i_d, buf[i++], 8, "tcf");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "de");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "te");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "we");
			printlf (" ");
			printByValue (escoPacket_d, buf[i++], 8, "eptms");
			printlf (" ");
			printByValue (escoPacket_d, buf[i++], 8, "eptsm");
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "plms");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "plsm");
			i += 2;
			printlf (" ");
			printByValue (airMode_d, buf[i++], 8, "am");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "nf"); /* HERE dictionary */
			break;

		case 0x7f0d: /* LMP_remove_eSCO_link_req; 1.2 only */
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "eh");
			printlf (" ");
			printByValue (errorCode_d, buf[i++], 8, "r");
			break;

		case 0x7f0e: /* LMP_absence_notify; 1.2 only */
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "aind");
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "af"); /* HERE dictionary */
			printlf (" ");
			printBigHex (&buf[i], 4, "ainst");
			i += 4;
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "aw");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i] | (buf[i + 1] << 8), 16, "aint");
			i += 2;
			printlf (" ");
			printBigHex (&buf[i], 5, "rm");
			i += 5;
			break;

		case 0x7f0f: /* LMP_max_absences; 1.2 only */
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "mai");
			break;

		case 0x7f10: /* LMP_channel_classification_req; 1.2 only */
			printlf (" ");
			printByValue (disabledEnabled_d, buf[i++], 8, "arm");
			printlf (" ");
			printByValue (NULL, buf[i] | buf[i + 1] << 8, 16, "amini");
			i += 2;
			printlf (" ");
			printByValue (NULL, buf[i] | buf[i + 1] << 8, 16, "amaxi");
			i += 2;
			break;

		case 0x7f11: /* LMP_channel_classification; 1.2 only */
		{
			unsigned f;

			printlf (" ");
			printBigHex (&buf[i], 10, "acc");
			printlf ("(");
			for (f = 0; f < 40; ++f)
			{
				if (f % 4 == 0 && f != 0)
				{
					printlf ("-");
				}
				printlf ("%c", "ugrb"[buf[i + f / 4] >> (f % 4 << 1) & 3]);
			}
			printlf (")");
			i += 10;
			break;
		}

		case 0x7f12: /* LMP_alias_address; 1.2 only */
			printlf (" ");
			printBigHex (&buf[i], 6, "baa");
			i += 6;
			printlf (" ");
			printByValue (NULL, buf[i] | buf[i + 1] << 8, 16, "r");
			i += 2;
			break;

		case 0x7f13: /* LMP_active_address; 1.2 only */
			printlf (" ");
			printBigHex (&buf[i], 6, "ba");
			i += 6;
			printlf (" ");
			printByValue (NULL, buf[i] | buf[i + 1] << 8, 16, "r");
			i += 2;
			printlf (" ");
			printBigHex (&buf[i], 4, "asi");
			i += 4;
			break;

		case 0x7f14: /* LMP_fixed_address; 1.2 only */
			printlf (" ");
			printBigHex (&buf[i], 6, "baf");
			i += 6;
			printlf (" ");
			printByValue (NULL, buf[i] | buf[i + 1] << 8, 16, "r");
			i += 2;
			break;

		case 0x7f15: /* LMP_sniff_sub_rate_req */
		case 0x7f16: /* LMP_sniff_sub_rate_res */
			printlf (" ");
			printByValue (NULL, buf[i++], 8, "sr");
			printlf (" ");
			printByValue (NULL, buf[i] | buf[i + 1] << 8, 16, "to");
			i += 2;
			printlf (" ");
			printBigHex (&buf[i], 4, "sri");
			i += 4;
			break;

		case 0x7f19: /* LMP_IO_capability_req */
		case 0x7f1a: /* LMP_IO_capability_res */
			printlf(" ");
			printByValue (iocap_d, buf[i++], 8, "iocap");
			printlf(" ");
			printByValue (oobpresent_d, buf[i++], 8, "oob");
			printlf(" ");
			printByValue (authenticationrequirements_d, buf[i++], 8, "ar");
			break;

		case 0x7f1e: /* LMP_keypress_notification */
			printlf(" ");
			printByValue (notificationtype_d, buf[i++], 8, "nt");
			break;

		case 0x7f1f: /* Enhanced Power Control request */
			printlf(" ");
			printByValue (enhanced_power_control_request_d, buf[i++], 1, "pareq");
			len = 0;
			break;

		case 0x7f20: /* Enhanced Power Control response */
			printlf(" ");
			printBigHex (&buf[i], 1, "parsp");
			printlf("(gfsk:");
			printByValue (enhanced_power_control_response_field_d,  buf[i]    &0x3, 1, "gfsk");
			printlf(" dqpsk:");
			printByValue (enhanced_power_control_response_field_d, (buf[i]>>2)&0x3, 1, "dqpsk");
			printlf(" 8dpsk:");
			printByValue (enhanced_power_control_response_field_d, (buf[i]>>4)&0x3, 1, "8dpsk");
			printlf(")");
			len = 0;
			break;

		/* just opcode based params */
		case 5:
		case 18:
		case 22: /* LMP_sniff; 1.0B only */
		case 24:
		case 26: /* LMP_park; 1.0B only */
		case 33:
		case 34:
		case 35:
		case 47:
		case 49:
		case 50:
		case 51:
		case 56:
		case 58: /* LMP_encryption_key_size_mask_req; 1.2 only */
		case 0x7f08: /* LMP_scatter_algorithms_req; 1.2 only */
		case 0x7f17: /* LMP_pause_encryption_req */
		case 0x7f18: /* LMP_resume_encrypion_req */
		case 0x7f1b: /* LMP_numeric_comparision_failed */
		case 0x7f1c: /* LMP_passkey_entry_failed */
		default:
			break;
		}
		}
		else {
			printlf (" ");
			len = ulpllclen[o<<1|tid];
			switch (o<<1|tid)
			{
			case 0: /* connection update req */
				{
					printByValue (ulp_llc_d, o<<1|tid, 16, "o");
					printlf (" win_size: 0x%.4x win_offset: 0x%.4x interval: 0x%.4x latency: 0x%.4x timeout: 0x%x",
						buf[i],
						buf[i+1]|(buf[i+2]<<8),
						buf[i+3]|(buf[i+4]<<8),
						buf[i+5]|(buf[i+6]<<8),
						buf[i+7]|(buf[i+8]<<8));

					printlf(" count:0x%.2x%.2x", buf[i+10], buf[i+9]);

					len = 0;
				}
				break;
			case 1: /* channel map req */
				{
					int j;
					printByValue (ulp_llc_d, o<<1|tid, 16, "o");
					printlf (" channel_map:0x");
					for (j = 4; j >= 0; j --)
						printlf ("%02x", buf[i+j]);
					printlf (" count:0x%x", buf[i+5]|(buf[i+6]<<8));
					printlf ("\n");
					len = 0;
				}
				break;
			case 2: /* terminate ind */
				printByValue (ulp_llc_d, o<<1|tid, 16, "o");
				printlf (" ");
				printByValue (errorCode_d, buf[i], 8, "r");
				len = 0;
				break;
			case 3: /* ll enc req */
				{
					int j;
					printByValue (ulp_llc_d, o<<1|tid, 16, "o");
					printlf (" RAND:0x");
					for (j = 7; j >= 0; j--)
						printlf ("%02x", buf[i+j]);
					printlf (" EDIV:0x");
					for (j = 9; j >= 8; j--)
						printlf ("%02x", buf[i+j]);
					printlf (" SKDm:0x");
					for (j = 15; j >= 10; j--)
						printlf ("%02x", buf[i+j]);
				}
				len = 0;
				break;
			case 4: /* ll enc rsp */
				{
					int j;
					printByValue (ulp_llc_d, o<<1|tid, 16, "o");
					printlf (" SKDs:0x");
					for (j = 7; j >= 0; j--)
						printlf ("%02x", buf[i+j]);
					printlf (" IVs:0x");
					for (j = 11; j >= 8; j--)
						printlf ("%02x", buf[i+j]);
				}
				len = 0;
				break;
			case 5: /* ll start enc req */
				printByValue (ulp_llc_d, o<<1|tid, 16, "o");
				break;
			case 6: /* ll start enc rsp */
				printByValue (ulp_llc_d, o<<1|tid, 16, "o");
				break;
			case 7: /* unknown rsp */
				printByValue (ulp_llc_d, o<<1|tid, 16, "o");
				printlf (" ");
				printByValue (ulp_llc_d, buf[i], 16, "o");
				break;
			case 8: /* feature req */
				{
					int j;
					printByValue (ulp_llc_d, o<<1|tid, 16, "o");
					printlf (" feature_set:0x");
					for (j = 7; j >= 0; j--)
						printlf ("%02x", buf[i+j]);
				}
				len = 0;
				break;
			case 9: /* feature rsp */
				{
					int j;
					printByValue (ulp_llc_d, o<<1|tid, 16, "o");
					printlf (" feature_set:0x");
					for (j = 7; j >= 0; j--)
						printlf ("%02x", buf[i+j]);
				}
				len = 0;
				break;
			case 10: /* pause enc req */
				printByValue (ulp_llc_d, o<<1|tid, 16, "o");
				break;
			case 11: /* pause enc rsp */
				printByValue (ulp_llc_d, o<<1|tid, 16, "o");
				break;
			case 12: /* version ind */
				{
					printByValue (ulp_llc_d, o<<1|tid, 16, "o");
					printlf (" ");
					printByValue (lmpVersion_d, buf[i+0], 8, "LLVersNr");
					printlf (" ");
					printByValue (manufacturerName_d, buf[i+2]<<8|buf[i+1], 16, "CompId");
					printlf (" ");
					printByValue (NULL, buf[i+4]<<8|buf[i+3], 16, "SubVersNr");
					if (buf[i+1] == 0xa /* CSR */ &&
						lookupByValue (id_d, buf[i+4]<<8|buf[i+3]))
					{
						printlf ("(");
						printByValue (id_d, buf[i+4]<<8|buf[i+3], 16, NULL);
						printlf (")");
					}
				}
				len = 0;
				break;
			case 13: /* reject ind */
				printByValue (ulp_llc_d, o<<1|tid, 16, "o");
				printlf (" ");
				printByValue (errorCode_d, buf[i], 8, "r");
				len = 0;
				break;
			case 0x99: /* continuation of an llc message */
				switch (buf[i])
				{
				case 3:
					{
						int j;
					    printlf (" SKDm(cont):0x");
						for (j = 2; j >= 1; j--)
							printlf ("%02x", buf[i+j]);
						printlf (" IVm:0x");
						for (j = 6; j >= 3; j--)
							printlf ("%02x", buf[i+j]);
					}
					len = 0;
					break;
				}
			default:
				break;
			}
		}
		break;
	}
	case HCI_DEBUG_EV_ACO:
	{
		int i;

		printlf (" 0x");
		for (i = 12; i > 0; --i)
		{
			printlf ("%02x", buf[i]);
		}

		len = 0;
		break;
	}

	case HCI_DEBUG_EV_ACL_HANDLE:

		printlf (" ");
		printByValue (ms_d, !buf[3], 8, "r");
		printlf (" ");
		printch (buf[1] | (buf[2] << 8));
		printlf (" ");
		printByValue (NULL, buf[5], 8, "am");
		if (!buf[3])
		{
			printlf (" ");
			printba (buf[7] | (buf[8] << 8) | ((u32) buf[9] << 16), buf[10], buf[11] | (buf[12] << 8));
			printlf (" ");
			printByValue (NULL, buf[13] | (buf[14] << 8) | ((u32) buf[15] << 16), 24, "cod");
			printlf (" ");
			printByValue (psrm_d, buf[17] & 0x03, 2, "psrm");
			printlf (" ");
			printByValue (pspm_d, (buf[17] >> 2) & 0x03, 2, "pspm");
			printlf (" ");
			printByValue (psm_d, buf[17] >> 4, 3, "psm");
		}
		len = 0;
		break;

	case HCI_DEBUG_EV_PKT_TYPES:
		printlf (" ");
		printch (buf[1] | (buf[2] << 8));
		printlf (" ");
		printByValue (packetType_d, buf[3] | (buf[4] << 8), 16, "pt");
		len = 0;
		break;

	case HCI_DEBUG_EV_SLAVE_MAX_SLOTS:
		printlf (" ");
		printch (buf[1] | (buf[2] << 8));
		ASSERT (buf[4] == 0);
		ASSERT (buf[3] <= 2);
		printlf (" ms:0x%02x", buf[3] * 2 + 1);
		len = 0;
		break;

	case HCI_DEBUG_EV_TID_FIX:
		printlf (" %c/", buf[3] & 1 ? 's' : 'm');
		printByValue (lmp_d, buf[1], 8, "o");
		len = 0;
		break;

	case HCI_DEBUG_EV_TO:
	case HCI_DEBUG_EV_TO_START:
	case HCI_DEBUG_EV_TO_CANCEL:
	case HCI_DEBUG_EV_TO_LOST:
		printlf (" ");
		printByValue(timer_d, buf[1], 1, NULL);
		/* printlf (" %c/", buf[1] & 1 ? 's' : 'm'); */
		printByValue (lmp_d, buf[5] | (buf[6] << 8), 16, "o");
		printlf (" ");
		printByValue (NULL, buf[3] | (buf[4] << 8), 16, "id");
		len = 0;
		break;

	case HCI_DEBUG_EV_BDW_TO:
	case HCI_DEBUG_EV_DETACH_TO:
		len = 0;
		break;

	case HCI_DEBUG_EV_CQDDR:
		printlf (" ");
		printch (buf[1] | (buf[2] << 8));
		printlf (" ");
		printByValue (NULL, buf[3] | (buf[4] << 8), 16, "ber");
		printlf (" ");
		ASSERT (buf[6] == 0);
		printByValue (NULL, buf[5], 8, "rs");
		printlf (" ");
		ASSERT (buf[8] == 0);
		printByValue (NULL, buf[7], 8, "npr");
		printlf (" ");
		ASSERT (buf[10] == 0);
		printByValue (NULL, buf[9], 8, "opr");

		len = 0;
		break;

	case HCI_DEBUG_EV_UNPARK:
		printlf (" ");
		printByValue (unpark_d, buf[1], 8, "rc");
		if (buf[1] < 0x10)
		{
			printlf (" ");
			printByValue (NULL, buf[3], 8, "am");
		}
		if (buf[1] == 0x0f)
		{
			printlf (" ");
			printch (buf[5] | (buf[6] << 8));
			printlf (" ");
			printByValue (ms_d, buf[7], 8, "r");
		}
		if (buf[1] < 0x0f)
		{
			printlf (" ");
			printByValue (NULL, buf[5], 8, "index");
			printlf (" ");
			printByValue (NULL, buf[7], 8, "tcf");
			printlf (" 0x%02x 0x%02x 0x%02x", buf[9], buf[11], buf[13]);
		}

		len = 0;
		break;

	case HCI_DEBUG_EV_INSTANT:
		printlf (" ");
		printlf ("0x%02x%02x%02x%02x", buf[4], buf[3], buf[2], buf[1]);
		printlf (" ");
		printByValue (NULL, buf[5], 8, "rc");
		len = 0;
		break;

	case HCI_DEBUG_EV_CONVERT_DSCO:
		printlf (" ts:%d ds:%d of:%d ow:%d tw:%d al:%d ws:%d ng:%d i2:%d",
			buf[1] | (buf[2] << 8),
			buf[3] | (buf[4] << 8),
			buf[5] | (buf[6] << 8),
			buf[7] | (buf[8] << 8),
			buf[9] | (buf[10] << 8),
			buf[11] | (buf[12] << 8),
			buf[13] | (buf[14] << 8),
			buf[15] | (buf[16] << 8),
			buf[17]);
		len = 0;
		break;

	case HCI_DEBUG_EV_SLOTS:
		printlf (" ");
		printch (buf[7] | (buf[8] << 8));
		printlf (" ");
		printByValue (NULL, buf[1] | (buf[2] << 8), 16, "cs");
		printlf (" ");
		printByValue (NULL, buf[3] | (buf[4] << 8), 16, "msm");
		printlf (" ");
		printByValue (NULL, buf[5] | (buf[6] << 8), 16, "mss");
		len = 0;
		break;

	case HCI_DEBUG_EV_SLOW_CLOCK:
	{
		u32 scpa = buf[15] |
			   ((u32) buf[16] << 8) |
			   ((u32) buf[17] << 16) |
			   ((u32) (buf[18] & 0x0f) << 24);
		unsigned shift = buf[18] >> 4;

		printlf (" ");
		printlf ("scpa:0x%08lx>>%u=0x%04lx", (ul) scpa, shift, (ul) (scpa >> shift));
		for (i = 1; i < 8; ++i)
		{
			u16 scps = buf[i * 2 - 1] | (buf[i * 2] << 8);
			if (scps == 0)
			{
				break;
			}
			printlf (" ");
			printlf ("scps%u:0x%04x", (unsigned) i, scps);
		}
		len = 0;
		break;
	}

	case HCI_DEBUG_EV_SNIFF_STATS:
		printlf (" ");
		printByValue (NULL, buf[1], 8, "txok");
		printlf (" ");
		printByValue (NULL, buf[2], 8, "rxok");
		printlf (" ");
		printByValue (NULL, buf[3], 8, "rxeto");
		printlf (" ");
		printByValue (NULL, buf[4], 8, "rxehdr");
		printlf (" ");
		printByValue (NULL, buf[5], 8, "rxepkt");
		len = 0;
		break;

	case HCI_DEBUG_EV_DOT11_CHANNEL:
		printlf (" ");
		ASSERT (buf[2] == 0);
		printByValue (NULL, buf[1], 4, "new");
		printlf (" ");
		ASSERT (buf[4] == 0);
		printByValue (NULL, buf[3], 4, "last");
		printlf (" ");
		ASSERT (buf[6] == 0);
		printByValue (NULL, buf[5], 4, "assoc");
		printlf (" ");
		ASSERT (buf[8] == 0);
		printByValue (NULL, buf[7], 4, "over");
		printlf (" ");
		ASSERT (buf[10] == 0);
		printByValue (NULL, buf[9], 8, "na");
		printlf (" ");
		ASSERT (buf[12] == 0);
		printByValue (NULL, buf[11], 8, "nd");
		len = 0;
		break;

	case 0xb4:
	case 0xb5:
	{
		unsigned f;

		printlf(" class      ");
		for (f = 0; f < 9*8; ++f)
		{
			if (f % 8 == 0 && f != 0)
			{
				printlf ("-");
			}
			printlf ("%c", "ugrb"[(buf[1 + f / 4] >> (f % 4 << 1)) & 3]);
		}
		len = 0;
		break;
	}
	case 0xb2:
		printlf(" %s ", (buf[1]==0)?"bad ":"good");
		printlf("op:%02x ", buf[3]);
		for (i=0; i<79; i++)
		{
			printlf("%d", (buf[5+(i/8)] >> (i%8)) & 0x01);
			if (i % 8 == 7)
				printlf(" ");
		}
		len = 0;
		break;



	/* Simple Pairing Debug Events */
	case HCI_DEBUG_EV_ECC_PRIVATE:
	case HCI_DEBUG_EV_ECC_PUBLIC_X:
	case HCI_DEBUG_EV_ECC_PUBLIC_Y:
	case HCI_DEBUG_EV_ECC_RESULT:
		if (buf[i++] == 1)
		{
			i++;
			printlf(" len: %2d [21..14]:", buf[i++]);
			len = min(8*2, len);
		}
		else
		{
			printlf("         [13.. 0]:");
			len = min(7*2, len);
		}
		i++;
		break;

	case HCI_DEBUG_EV_U:
		if (buf[i++] == 1)
			printlf(" U[ 0..11]:");
		else
			printlf(" U[12..23]:");
		i++;
		len = min(14, len);
		break;

	case HCI_DEBUG_EV_V:
		if (buf[i++] == 1)
			printlf(" V[ 0..11]:");
		else
			printlf(" V[12..23]:");
		i++;
		len = min(14, len);
		break;

	case HCI_DEBUG_EV_X:
		printlf(" X[0..15]:");
		len = min(16,len);
		break;

	case HCI_DEBUG_EV_F1:
		if (len < 18)
			printlf(" ERROR:");
		else
		{
			printlf(" Z: 0x%02x f1[0..15]:", buf[i++]);
			i++;
			len = min(18, len);
		}
		break;

	case HCI_DEBUG_EV_Y:
		printlf(" Y[0..15]:");
		len = min(16,len);
		break;

	case HCI_DEBUG_EV_W:
		if (buf[i++] == 1)
			printlf(" W[ 0..11]:");
		else
			printlf(" W[12..23]:");
		i++;
		len = min(14, len);
		break;

	case HCI_DEBUG_EV_N:
		printlf(" N%d[0..15]:", buf[i++]);
		i++;
		len = min(18, len);
		break;

	case HCI_DEBUG_EV_KEYA1A2:
		if (len < 16)
			printlf(" ERROR:");
		else
		{
			printlf(" KeyID:");
			for (; i <= 4; ++i)
			{
				printlf (" 0x%02x(%c)", buf[i], buf[i]);
			}
			printlf(" A1:");
			for (; i <= 10; ++i)
			{
				printlf (" 0x%02x", buf[i]);
			}
			printlf(" A2:");

			for (; i <= 16; ++i)
			{
				printlf (" 0x%02x", buf[i]);
			}
			len = 0;
		}
		break;

	case HCI_DEBUG_EV_F:
		printlf(" f%d[0..15]:", buf[i++]);
		i++;
		len = min(18, len);
		break;

	case HCI_DEBUG_EV_IOCAP1A2:
		if (len < 16)
			printlf(" ERROR:");
		else
		{
			printlf(" IOCap:");
			for (; i <= 3; ++i)
			{
				printlf (" 0x%02x", buf[i]);
			}

			printlf(" A1:");
			for (; i <= 9; ++i)
			{
				printlf (" 0x%02x", buf[i]);
			}

			printlf(" A2:");
			for (; i <= 15; ++i)
			{
				printlf (" 0x%02x", buf[i]);
			}
			len = 0;
		}
		break;

	case HCI_DEBUG_EV_R:
		printlf(" R[0..15]:");
		len = min(16,len);
		break;

	case HCI_DEBUG_EV_ULP_ADV_CHANNEL:
		len = decodeULPAdvDebug(buf, len);
		break;

	} /* end switch */

	for (; i <= len; ++i)
	{
		printlf (" 0x%02x", buf[i]);
	}
	printlf ("\n");
}
